录制：redis基础14_缓存.mp4
日期：2026-01-30 22:34:36
录制文件：https://meeting.tencent.com/crm/l5mxeXRVf7

Q1: Redis 作为缓存的一般使用逻辑？

**核心模式：Cache-Aside（旁路缓存）**

**基本流程**：

1. **查询数据**：
   ```
   先查缓存 → 命中返回 → 未命中查数据库 → 写入缓存 → 返回
   ```

2. **更新数据**：
   ```
   更新数据库 → 更新/删除缓存
   ```

3. **删除数据**：
   ```
   删除数据库 → 删除缓存
   ```

**关键要点**：

- **缓存失效策略**：设置过期时间（TTL），避免数据长期不一致
- **缓存更新策略**：先更新数据库，再更新/删除缓存（保证数据一致性）
- **容错处理**：缓存操作失败不影响业务逻辑（只记录日志）
- **空值处理**：查询不存在的数据不缓存（避免缓存穿透，可扩展为空值缓存）

**代码示例**：

```go
// 查询：Cache-Aside 模式
func GetUser(id int64) (*User, error) {
    // 1. 先查缓存
    user, err := cache.Get(id)
    if err == nil && user != nil {
        return user, nil  // 缓存命中
    }
    
    // 2. 缓存未命中，查数据库
    user, err = db.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存（设置过期时间）
    cache.Set(id, user, 300)  // 5分钟过期
    
    return user, nil
}

// 更新：先更新数据库，再更新缓存
func UpdateUser(user *User) error {
    db.Update(user)      // 1. 更新数据库
    cache.Set(user)      // 2. 更新缓存
    return nil
}
```

**实际应用场景**：

- **热点数据缓存**：用户信息、商品信息、配置信息
- **查询结果缓存**：减少数据库查询压力
- **HTTP响应缓存**：缓存第三方API响应

**注意事项**：

- 缓存穿透：查询不存在的数据（解决：空值缓存或布隆过滤器）
- 缓存雪崩：大量缓存同时过期（解决：随机过期时间）
- 缓存击穿：热点数据过期（解决：分布式锁或永不过期）

---

## 详细说明

### 1. Cache-Aside 模式（最常用）

**特点**：
- 应用程序负责维护缓存
- 缓存和数据库独立，缓存失效不影响数据库

**流程**：
```
查询：
  1. 查缓存 → 命中 → 返回
  2. 查缓存 → 未命中 → 查数据库 → 写缓存 → 返回

更新：
  1. 更新数据库
  2. 更新/删除缓存

删除：
  1. 删除数据库
  2. 删除缓存
```

**优点**：
- 实现简单
- 缓存失效不影响数据库
- 适合读多写少的场景

**缺点**：
- 可能出现数据不一致（缓存更新失败）
- 首次查询需要查数据库

### 2. 其他缓存模式（了解）

**Write-Through（写穿透）**：
- 先写缓存，再写数据库
- 保证缓存和数据库一致，但写入性能较低

**Write-Back（写回）**：
- 先写缓存，异步写数据库
- 写入性能高，但可能丢失数据

### 3. 缓存更新策略

**策略1：更新缓存（推荐）**
```go
db.Update(user)
cache.Set(user)  // 更新缓存
```

**策略2：删除缓存**
```go
db.Update(user)
cache.Delete(user)  // 删除缓存，下次查询时重新加载
```

**选择原则**：
- 读多写少：更新缓存
- 写多读少：删除缓存
- 数据一致性要求高：删除缓存

### 4. 缓存过期时间设置

**原则**：
- 根据数据更新频率设置
- 热点数据：较长过期时间（如30天）
- 实时性要求高：较短过期时间（如5分钟）
- 避免缓存雪崩：设置随机过期时间

**示例**：
```go
// 固定过期时间
cache.Set(key, value, 300)  // 5分钟

// 随机过期时间（避免雪崩）
expire := 300 + rand.Intn(60)  // 5-6分钟随机
cache.Set(key, value, expire)
```

### 5. 容错处理

**原则**：缓存操作失败不影响业务逻辑

```go
// 查询：缓存失败继续查数据库
user, err := cache.Get(id)
if err != nil {
    // 缓存失败，继续查数据库
    user, err = db.FindByID(id)
}

// 写入：缓存失败只记录日志
if err := cache.Set(id, user); err != nil {
    log.Printf("缓存写入失败: %v", err)
    // 不影响返回结果
}
```

### 6. 项目中的实际应用

**参考代码**：
- `experiments/cache-demo/service/user_service.go` - Cache-Aside 模式实现
- `model/redismodel/token.go` - Token 信息缓存（30天过期）

**最佳实践**：
1. 先查缓存，未命中再查数据库
2. 设置合理的过期时间
3. 更新数据时同步更新缓存
4. 缓存操作失败不影响业务逻辑
5. 注意处理缓存穿透、雪崩、击穿问题