录制：redis基础20_分布式锁简述.mp4
日期：2026-01-30 22:20:21
录制文件：https://meeting.tencent.com/crm/2GwkQY4Bf2

录制：redis基础21_分布式锁实践.mp4
日期：2026-01-30 22:54:17
录制文件：https://meeting.tencent.com/crm/2MRnrJM458


Q1: 什么是分布式锁？

## 面试回答（精简版）

**定义**：分布式锁是在分布式系统中，用于控制多个进程/线程对共享资源的访问的机制。

**核心特点**：
- **互斥性**：同一时刻只有一个进程能获得锁
- **可重入性**：同一个进程可以多次获取同一把锁（可选）
- **超时释放**：锁有过期时间，防止死锁
- **高可用性**：锁服务需要高可用

**与本地锁的区别**：
- **本地锁**：单机环境下，控制同一进程内的多个线程
- **分布式锁**：分布式环境下，控制多个进程/多台服务器

**示例**：
```
单机环境：
线程A 和 线程B 竞争同一资源 → 使用本地锁（mutex）

分布式环境：
服务器A的进程 和 服务器B的进程 竞争同一资源 → 使用分布式锁
```

---

## 详细说明

### 1. 分布式锁的定义

**分布式锁（Distributed Lock）**是在分布式系统中，用于控制多个进程/线程对共享资源的访问的同步机制。

**核心特性**：
- **互斥性（Mutual Exclusion）**：同一时刻只有一个进程能获得锁
- **可重入性（Reentrant）**：同一个进程可以多次获取同一把锁（可选）
- **超时释放（Timeout）**：锁有过期时间，防止死锁
- **高可用性（High Availability）**：锁服务需要高可用，不能单点故障

### 2. 与本地锁的区别

| 特性 | 本地锁 | 分布式锁 |
|------|--------|----------|
| **作用范围** | 单进程内 | 跨进程/跨服务器 |
| **实现方式** | mutex、semaphore | Redis、ZooKeeper、etcd |
| **性能** | 快（内存操作） | 较慢（网络操作） |
| **复杂度** | 简单 | 复杂 |

### 3. 分布式锁的应用场景

- **防止重复操作**：防止重复提交、重复处理
- **资源竞争**：控制对共享资源的访问
- **分布式任务调度**：确保任务只执行一次
- **缓存击穿防护**：防止热点数据过期时大量请求访问数据库

---

Q2: 什么时候需要分布式锁？

## 面试回答（精简版）

**核心场景**：多个进程/服务器需要互斥访问共享资源时。

**为什么需要分布式锁？普通锁不行吗？**

**答案**：普通锁（如 `sync.Mutex`）只能控制**单进程内的多个线程**，无法控制**跨进程/跨服务器的并发访问**。

**示例**：
```
单机单进程：普通锁（mutex）足够
  └─ 线程A 和 线程B 竞争资源 → 使用 mutex

分布式环境（多进程/多服务器）：必须使用分布式锁
  └─ 服务器A的进程 和 服务器B的进程 竞争资源 → 使用分布式锁
```

**典型场景**：

1. **防止重复操作**
   - 防止重复提交订单
   - 防止重复处理消息
   - 防止重复执行定时任务

2. **资源竞争**
   - 库存扣减（防止超卖）
   - 账户余额操作（防止并发问题）
   - 文件操作（防止并发写入）

3. **分布式任务调度**
   - 确保定时任务只执行一次
   - 防止多个节点同时执行任务

4. **缓存击穿防护**
   - 热点数据过期时，使用分布式锁防止大量请求同时访问数据库

**判断标准**：
- 是否涉及多个进程/服务器？
- 是否需要互斥访问？
- 是否会导致数据不一致？

**示例**：
```
场景1：库存扣减（分布式环境）
问题：多个订单同时扣减库存，可能超卖
原因：普通锁（mutex）只能锁住单进程内的线程，无法锁住其他服务器的进程
解决：使用分布式锁，确保同一时刻只有一个订单能扣减库存（跨服务器）

场景2：防止重复提交
问题：用户快速点击提交按钮，可能重复提交
原因：请求可能被分发到不同的服务器，普通锁无法跨服务器控制
解决：使用分布式锁，确保同一请求只处理一次（跨服务器）
```

---

## 详细说明

### 1. 防止重复操作

**场景**：防止重复提交、重复处理

**示例**：
```go
// 场景：防止重复提交订单
func SubmitOrder(orderID string) error {
    // 1. 尝试获取锁
    lock, ok, err := Lock(ctx, redis, fmt.Sprintf("order:%s", orderID), 30)
    if !ok {
        return fmt.Errorf("订单正在处理中")
    }
    defer ReleaseLock(lock)
    
    // 2. 检查订单是否已存在
    if orderExists(orderID) {
        return fmt.Errorf("订单已存在")
    }
    
    // 3. 创建订单
    return createOrder(orderID)
}
```

### 2. 资源竞争

**场景**：库存扣减、账户余额操作

#### 2.1 为什么普通锁无法解决分布式环境下的问题？

**问题分析**：为什么需要使用分布式锁？普通锁不能解决这个问题吗？

**答案**：普通锁（本地锁）**只能控制单进程内的多个线程**，无法控制**跨进程/跨服务器的并发访问**。

**详细说明**：

##### 场景：库存扣减（分布式环境）

**架构**：
```
用户请求 → 负载均衡器 → 服务器A（进程1）  ← 共享数据库
                      → 服务器B（进程2）  ← 共享数据库
                      → 服务器C（进程3）  ← 共享数据库
```

**问题场景**：
1. 商品库存：100件
2. 用户A在服务器A下单：购买50件
3. 用户B在服务器B下单：购买60件
4. 两个请求**几乎同时到达**

**使用普通锁（mutex）的问题**：

```go
// ❌ 错误：使用普通锁（只能控制单进程内的线程）
var mu sync.Mutex

func DeductStock(productID string, quantity int) error {
    mu.Lock()  // 只能锁住当前进程内的线程
    defer mu.Unlock()
    
    // 服务器A的进程1：读取库存 = 100
    stock := getStock(productID)  // 100
    
    // 服务器B的进程2：读取库存 = 100（因为锁不住其他进程！）
    // stock := getStock(productID)  // 100
    
    // 服务器A：扣减50，库存 = 50
    updateStock(productID, stock-quantity)  // 100 - 50 = 50
    
    // 服务器B：扣减60，库存 = 40（超卖了！）
    // updateStock(productID, stock-quantity)  // 100 - 60 = 40
}
```

**执行时序**：
```
时间线：
T1: 服务器A进程1 获取本地锁（mutex）
T2: 服务器A进程1 读取库存 = 100
T3: 服务器B进程2 获取本地锁（mutex）← 服务器B的锁，不影响服务器A！
T4: 服务器B进程2 读取库存 = 100  ← 问题：读取到旧值！
T5: 服务器A进程1 扣减50，库存 = 50
T6: 服务器B进程2 扣减60，库存 = 40  ← 超卖！实际库存应该是-10
```

**结果**：**超卖**！实际库存应该是 -10，但数据库显示 40。

**原因分析**：

| 锁类型 | 作用范围 | 能否跨进程 | 能否跨服务器 |
|--------|----------|------------|--------------|
| **普通锁（mutex）** | 单进程内的线程 | ❌ 不能 | ❌ 不能 |
| **分布式锁** | 跨进程/跨服务器 | ✅ 能 | ✅ 能 |

**普通锁的限制**：
- `sync.Mutex` 是**进程内**的锁，只能控制**同一进程内的多个线程**
- 不同进程/不同服务器的锁是**独立的**，互不影响
- 在分布式环境下，多个进程可以**同时**访问共享资源（数据库）

**使用分布式锁的解决方案**：

```go
// ✅ 正确：使用分布式锁（可以控制跨进程/跨服务器）
func DeductStock(productID string, quantity int) error {
    lockKey := fmt.Sprintf("stock:%s", productID)
    
    // 获取分布式锁（所有服务器共享同一个锁）
    lock, ok, err := Lock(ctx, redis, lockKey, 10)
    if !ok {
        return fmt.Errorf("库存操作繁忙，请稍后重试")
    }
    defer ReleaseLock(lock)  // 确保释放锁
    
    // 服务器A的进程1：获取锁成功，读取库存 = 100
    stock := getStock(productID)  // 100
    
    // 服务器B的进程2：获取锁失败，等待...
    // （因为服务器A已经持有锁）
    
    if stock < quantity {
        return fmt.Errorf("库存不足")
    }
    
    // 服务器A：扣减50，库存 = 50
    updateStock(productID, stock-quantity)  // 100 - 50 = 50
    
    // 服务器A：释放锁
    
    // 服务器B的进程2：获取锁成功，读取库存 = 50
    // stock := getStock(productID)  // 50
    
    // 服务器B：扣减60，库存不足，返回错误
    // if stock < quantity { return error }
}
```

**执行时序**：
```
时间线：
T1: 服务器A进程1 获取分布式锁（Redis）
T2: 服务器A进程1 读取库存 = 100
T3: 服务器B进程2 尝试获取分布式锁（Redis）← 失败！等待...
T4: 服务器A进程1 扣减50，库存 = 50
T5: 服务器A进程1 释放分布式锁
T6: 服务器B进程2 获取分布式锁成功
T7: 服务器B进程2 读取库存 = 50
T8: 服务器B进程2 检查：50 < 60，返回"库存不足"
```

**结果**：**正确**！防止了超卖。

##### 对比总结

| 场景 | 普通锁（mutex） | 分布式锁 |
|------|----------------|----------|
| **单机单进程** | ✅ 可以 | ✅ 可以 |
| **单机多进程** | ❌ 不行 | ✅ 可以 |
| **多机多进程** | ❌ 不行 | ✅ 可以 |
| **分布式环境** | ❌ **无法解决** | ✅ **可以解决** |

**结论**：
- **单机单进程**：普通锁（mutex）足够
- **分布式环境**（多进程/多服务器）：**必须使用分布式锁**

**示例**：
```go
// 场景：库存扣减（防止超卖）
func DeductStock(productID string, quantity int) error {
    lockKey := fmt.Sprintf("stock:%s", productID)
    lock, ok, err := Lock(ctx, redis, lockKey, 10)
    if !ok {
        return fmt.Errorf("库存操作繁忙，请稍后重试")
    }
    defer ReleaseLock(lock)
    
    // 检查库存
    stock := getStock(productID)
    if stock < quantity {
        return fmt.Errorf("库存不足")
    }
    
    // 扣减库存
    return updateStock(productID, stock-quantity)
}
```

### 3. 分布式任务调度

**场景**：确保定时任务只执行一次

**示例**：
```go
// 场景：定时任务（防止多个节点同时执行）
func ScheduledTask() {
    lock, ok, err := Lock(ctx, redis, "scheduled:task:daily", 3600)
    if !ok {
        log.Println("任务正在其他节点执行")
        return
    }
    defer ReleaseLock(lock)
    
    // 执行任务
    doTask()
}
```

### 4. 缓存击穿防护

**场景**：热点数据过期时，防止大量请求同时访问数据库

**示例**：
```go
// 场景：缓存击穿防护
func GetHotData(key string) (interface{}, error) {
    // 1. 先查缓存
    data, err := cache.Get(key)
    if err == nil && data != nil {
        return data, nil
    }
    
    // 2. 获取分布式锁
    lock, ok, err := Lock(ctx, redis, fmt.Sprintf("lock:%s", key), 5)
    if !ok {
        // 等待一段时间后重新查询缓存
        time.Sleep(100 * time.Millisecond)
        return cache.Get(key)
    }
    defer ReleaseLock(lock)
    
    // 3. 双重检查（Double Check）
    data, err = cache.Get(key)
    if err == nil && data != nil {
        return data, nil
    }
    
    // 4. 查询数据库
    data, err = db.Query(key)
    if err != nil {
        return nil, err
    }
    
    // 5. 写入缓存
    cache.Set(key, data, 300)
    
    return data, nil
}
```

---

Q3: 如何实现分布式锁？

## 面试回答（精简版）

**核心实现**：使用 Redis 的 `SET key value NX EX timeout`

**基本实现**：

```go
// 1. 获取锁
SET lock:order:123 "unique_value" NX EX 30
// NX: 仅当key不存在时设置
// EX: 设置过期时间30秒

// 2. 执行业务逻辑
// ...

// 3. 释放锁（使用Lua脚本保证原子性）
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```

**关键要点**：
1. **SET NX EX**：原子性设置锁和过期时间
2. **唯一值**：使用唯一值（如UUID）标识锁的持有者
3. **Lua脚本**：释放锁时使用Lua脚本保证原子性
4. **超时时间**：设置合理的过期时间，防止死锁

**代码示例**：

```go
// 获取锁
func AcquireLock(key string, expireSeconds int) (bool, error) {
    value := generateUniqueValue()  // 生成唯一值（如UUID）
    result, err := redis.SetNX(key, value, expireSeconds)
    return result, err
}

// 释放锁（Lua脚本）
func ReleaseLock(key string, value string) error {
    script := `
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
    `
    redis.Eval(script, []string{key}, []string{value})
    return nil
}
```

---

## 详细说明

### 1. 基本实现（SET NX EX）

#### 1.1 获取锁

**Redis 命令**：
```redis
SET lock:order:123 "unique_value" NX EX 30
```

**参数说明**：
- `NX`：仅当key不存在时设置（Not eXists）
- `EX`：设置过期时间（秒）
- `unique_value`：唯一值，用于标识锁的持有者

**Go 代码**：
```go
func AcquireLock(redis *redis.Redis, key string, expireSeconds int) (bool, error) {
    // 生成唯一值（UUID）
    value := uuid.New().String()
    
    // SET NX EX：原子性设置锁和过期时间
    result, err := redis.SetNX(key, value, expireSeconds)
    if err != nil {
        return false, err
    }
    
    if result {
        // 保存value，用于释放锁时验证
        // 实际实现中，可以将value保存在锁对象中
    }
    
    return result, nil
}
```

#### 1.2 释放锁

**问题**：直接 `DEL` 可能删除其他进程的锁

**错误示例**：
```go
// 错误：可能删除其他进程的锁
redis.Del("lock:order:123")
// 如果进程A的锁已过期，进程B获得了锁
// 进程A执行DEL，会删除进程B的锁！
```

**正确实现**：使用 Lua 脚本保证原子性

**Lua 脚本**：
```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```

**Go 代码**：
```go
func ReleaseLock(redis *redis.Redis, key string, value string) error {
    script := `
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
    `
    
    _, err := redis.Eval(script, []string{key}, []string{value})
    return err
}
```

### 2. 完整实现示例

```go
type DistributedLock struct {
    redis  *redis.Redis
    key    string
    value  string
    expire int
}

func NewDistributedLock(redis *redis.Redis, key string, expireSeconds int) *DistributedLock {
    return &DistributedLock{
        redis:  redis,
        key:    key,
        value:  uuid.New().String(),  // 生成唯一值
        expire: expireSeconds,
    }
}

func (dl *DistributedLock) Acquire() (bool, error) {
    // SET NX EX：原子性设置锁和过期时间
    result, err := dl.redis.SetNX(dl.key, dl.value, dl.expire)
    if err != nil {
        return false, err
    }
    return result, nil
}

func (dl *DistributedLock) Release() error {
    script := `
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
    `
    _, err := dl.redis.Eval(script, []string{dl.key}, []string{dl.value})
    return err
}

// 使用示例
func Example() {
    lock := NewDistributedLock(redis, "lock:order:123", 30)
    
    // 获取锁
    ok, err := lock.Acquire()
    if !ok {
        log.Println("获取锁失败")
        return
    }
    defer lock.Release()  // 确保释放锁
    
    // 执行业务逻辑
    doSomething()
}
```

### 3. 常见问题和解决方案

#### 问题1：锁过期时间设置

**问题**：过期时间设置不合理
- 太短：业务未执行完，锁已过期
- 太长：进程崩溃后，锁长时间不释放

**解决方案**：
- **锁续期（Watch Dog）**：后台线程定期续期
- **合理设置**：根据业务执行时间设置，留有余量

**锁续期实现**：
```go
func (dl *DistributedLock) Renew() error {
    script := `
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("expire", KEYS[1], ARGV[2])
        else
            return 0
        end
    `
    _, err := dl.redis.Eval(script, []string{dl.key}, []string{dl.value, strconv.Itoa(dl.expire)})
    return err
}

// 后台续期
func (dl *DistributedLock) StartRenewal() {
    go func() {
        ticker := time.NewTicker(time.Duration(dl.expire/3) * time.Second)
        defer ticker.Stop()
        for range ticker.C {
            if err := dl.Renew(); err != nil {
                log.Printf("锁续期失败: %v", err)
                break
            }
        }
    }()
}
```

#### 问题2：锁被误删

**问题**：进程A的锁过期，进程B获得锁，进程A释放锁时误删进程B的锁

**解决方案**：
- 使用唯一值标识锁的持有者
- 释放锁时验证value是否匹配
- 使用Lua脚本保证原子性

#### 问题3：Redis单点故障

**问题**：Redis单点故障导致锁服务不可用

**解决方案**：
- **Redis Sentinel**：主从切换，高可用
- **Redis Cluster**：集群模式，高可用
- **Redlock算法**：多Redis实例，多数同意

### 4. Redlock算法（Redis分布式锁算法）

**原理**：在多个Redis实例上获取锁，多数同意才算成功

**流程**：
```
1. 获取当前时间（毫秒）
2. 依次在N个Redis实例上获取锁
3. 计算获取锁的总耗时
4. 如果获取锁的实例数 >= N/2+1，且耗时 < 锁过期时间
   → 获取锁成功
5. 否则，释放所有已获取的锁
```

**优点**：
- 高可用：即使部分Redis实例故障，仍可用
- 安全性高：多数同意机制

**缺点**：
- 实现复杂
- 性能较低（需要访问多个Redis实例）

**适用场景**：
- 对安全性要求极高的场景
- Redis集群环境

### 5. 使用go-zero的RedisLock

**项目中的实现**（参考 `apps/market/pkg/redis/locker.go`）：

```go
func Lock(ctx context.Context, kv *redis.Redis, key string, expire int) (lock *redis.RedisLock, ok bool, err error) {
    lock = redis.NewRedisLock(kv, key)
    lock.SetExpire(expire)
    ok, err = lock.AcquireCtx(ctx)
    return lock, ok, err
}

func MustLock(ctx context.Context, kv *redis.Redis, key string, expire int, timeout int) (lock *redis.RedisLock, err error) {
    timer := time.NewTimer(time.Duration(timeout) * time.Second)
    defer timer.Stop()
    for {
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        case <-timer.C:
            return nil, ErrLockTimeout
        default:
            lock, ok, err := Lock(ctx, kv, key, expire)
            if ok {
                return lock, nil
            }
            time.Sleep(100 * time.Millisecond)
        }
    }
}

func ReleaseLock(lock *redis.RedisLock) {
    if lock != nil {
        lock.Release()
    }
}
```

**使用示例**：
```go
// 获取锁（带超时）
lock, err := MustLock(ctx, redis, "lock:order:123", 30, 5)
if err != nil {
    return fmt.Errorf("获取锁失败: %w", err)
}
defer ReleaseLock(lock)

// 执行业务逻辑
doSomething()
```

### 6. 最佳实践

#### 6.1 锁的命名

**原则**：清晰、唯一、有意义

```go
// 好的命名
lock:order:123          // 订单锁
lock:stock:product:456  // 商品库存锁
lock:user:789:update    // 用户更新锁

// 不好的命名
lock1                   // 不清晰
lock                    // 可能冲突
```

#### 6.2 过期时间设置

**原则**：根据业务执行时间设置，留有余量

```go
// 示例：订单处理预计10秒，设置30秒过期时间
lock, _ := Lock(ctx, redis, "lock:order:123", 30)
```

#### 6.3 锁的释放

**原则**：确保释放锁，使用 defer

```go
lock, ok, err := Lock(ctx, redis, key, 30)
if !ok {
    return err
}
defer ReleaseLock(lock)  // 确保释放锁

// 执行业务逻辑
```

#### 6.4 错误处理

**原则**：获取锁失败时，不要继续执行业务逻辑

```go
lock, ok, err := Lock(ctx, redis, key, 30)
if err != nil {
    return fmt.Errorf("获取锁失败: %w", err)
}
if !ok {
    return fmt.Errorf("锁已被其他进程持有")
}
defer ReleaseLock(lock)
```

### 7. 与其他方案的对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **Redis分布式锁** | 实现简单，性能好 | 单点故障风险 | 大多数场景（推荐） |
| **ZooKeeper** | 高可用，强一致性 | 性能较低，实现复杂 | 强一致性要求 |
| **etcd** | 高可用，强一致性 | 性能较低 | 强一致性要求 |
| **数据库锁** | 简单 | 性能差，可能死锁 | 不推荐 |

### 8. 总结

**Redis分布式锁**是分布式系统中常用的同步机制，核心实现：

1. **获取锁**：`SET key value NX EX timeout`
2. **释放锁**：使用Lua脚本验证value后删除
3. **关键要点**：
   - 使用唯一值标识锁的持有者
   - 设置合理的过期时间
   - 使用Lua脚本保证原子性
   - 确保释放锁（使用defer）

**最佳实践**：
- 使用go-zero的RedisLock（已封装好）
- 合理设置过期时间
- 确保释放锁
- 处理获取锁失败的情况