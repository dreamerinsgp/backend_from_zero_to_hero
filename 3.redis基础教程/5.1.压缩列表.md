录制：redis基础6_ziplist数据结构.mp4
日期：2026-01-30 22:20:21
录制文件：https://meeting.tencent.com/crm/KWAqE8g432

Q1：ZIPLIST压缩列表数据结构？

是一种内存高效的连续内存数据结构，用于存储小数据量的列表或键值对。
1）连续内存：所有数据存储在连续的内存块中
2）变长编码：根据数据大小动态选择编码方式，节省内存
3）双向遍历：可以从前向后或从后向前遍历

Q2: 图
ziplist 内存布局：
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ zlbytes │ zltail   │  zllen  │ entry1  │ entry2  │  zlend  │
│ (4字节) │ (4字节)  │ (2字节) │ (变长)  │ (变长)  │ (1字节) │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘

字段含义：
1） zlbytes: 整个ziplist占用的字节数
2） zltail: 最后一个entry的偏移量 (起始位置 + 偏移量 = 最后一个entry的位置)
3） zllen: entry的数量 (65535)
4)  entries: 实际的元素 (field 和 value会交替存储)
5)  zlend: 结束标记 (固定值: 0xFF)

每个entry的结构：
┌──────────┬──────────┬──────────┐
│ prevlen  │ encoding  │   data   │
│ (变长)   │ (1-5字节)│ (变长)   │
└──────────┴──────────┴──────────┘
1）prevlen: 前一个entry的长度
2）encoding: 编码方式
3）data: 实际数据

Q3: 实例： 简单的Hash存储 
HSET user:1001 name "Alice" age "25"

[zlbytes=50] [zltail=35] [zllen=4] 
[prevlen=0] [encoding=00xxxxxx] "name"      ← entry1: field
[prevlen=6] [encoding=00xxxxxx] "Alice"    ← entry2: value
[prevlen=12] [encoding=00xxxxxx] "age"     ← entry3: field
[prevlen=5] [encoding=00xxxxxx] "25"       ← entry4: value
[zlend=0xFF]

Q4：如何正向和反向遍历所有entry?
1）正向
prevlen(1) + encoding (1) + 4 = 6
[10, 16）第一个entry  -> 

2）反向
zltail -> last entry -> 当前位置 - prevlen -> 前一个entry 

假设 ZIPLIST 存储了：`["name", "Alice", "age", "25"]`
内存布局（简化）：
┌─────────────────────────────────────────────────────────┐
│ offset │ entry  │ prevlen │ encoding │ data            │
├────────┼────────┼─────────┼──────────┼─────────────────┤
│ 0x00   │ entry1 │ 0       │ ...      │ "name"          │
│ 0x06   │ entry2 │ 6       │ ...      │ "Alice"         │
│ 0x12   │ entry3 │ 12      │ ...      │ "age"           │
│ 0x18   │ entry4 │ 5       │ ...      │ "25"            │
│ 0x1F   │ zlend  │ -       │ 0xFF     │ -               │
└─────────────────────────────────────────────────────────┘

反向遍历过程 (从entry4 -> entry1)
当前位置： entry4 (offset: 0x18)
1. 读取entry4的prevlen = 5
2. 向前移动： 0x18 - 5 = 0x13
3. 找到entry3 (offset 0x12,实际上0x13-1 = 0x12)
重复这个过程~