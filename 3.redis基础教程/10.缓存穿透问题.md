录制：redis基础16_缓存穿透及方案1_空值缓存.mp4
日期：2026-01-30 22:29:03
录制文件：https://meeting.tencent.com/crm/lvdEzVvP08

录制：redis基础17_缓存穿透及方案2_布隆过滤器.mp4
日期：2026-01-30 22:27:30
录制文件：https://meeting.tencent.com/crm/KPR1nVPB5a


Q1: 什么是缓存穿透？

## 面试回答（精简版）

**定义**：查询不存在的数据，导致每次请求都穿透缓存直接访问数据库。

**问题本质**：
- 查询的数据既不在缓存中，也不在数据库中
- 查询结果为空，无法缓存
- 每次相同查询都会访问数据库，造成数据库压力

**解决方案**：

1. **空值缓存**（推荐）
   - 将空结果也缓存起来，设置较短的过期时间（如60秒）
   - 下次查询相同数据时，直接返回空值，不访问数据库

2. **布隆过滤器**
   - 在查询前先判断数据是否存在
   - 如果布隆过滤器判断不存在，直接返回，不查询数据库

**代码示例**：

```go
func GetUser(id int64) (*User, error) {
    // 1. 先查缓存
    user, err := cache.Get(id)
    if err == nil {
        if user == nil {
            return nil, fmt.Errorf("用户不存在")  // 空值缓存命中
        }
        return user, nil  // 正常缓存命中
    }
    
    // 2. 缓存未命中，查数据库
    user, err = db.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存（包括空值）
    if user == nil {
        // 空值缓存，设置短过期时间（60秒）
        cache.Set(id, nil, 60)
        return nil, fmt.Errorf("用户不存在")
    } else {
        // 正常缓存，设置长过期时间（5分钟）
        cache.Set(id, user, 300)
    }
    
    return user, nil
}
```

---

## 详细说明

### 1. 缓存穿透的定义

**缓存穿透（Cache Penetration）**是指查询一个**根本不存在的数据**，导致：
- 缓存中查不到（未命中）
- 数据库中也没有（查询结果为空）
- 每次查询都直接访问数据库
- 无法缓存空结果，形成恶性循环

### 2. 问题场景

#### 场景1：恶意攻击
```
攻击者故意查询不存在的用户ID（如：999999, 999998, 999997...）
每次查询都穿透缓存，直接访问数据库
短时间内大量无效查询，导致数据库压力骤增
```

#### 场景2：业务逻辑问题
```
用户查询已删除的商品ID
商品已从数据库删除，但缓存中没有
每次查询都访问数据库，返回空结果
```

#### 场景3：数据不存在
```
查询不存在的订单号、商品ID、用户ID等
这些ID在数据库中根本不存在
但每次查询都会访问数据库
```

### 3. 问题影响

**对系统的影响**：
- **数据库压力**：大量无效查询直接打到数据库
- **性能下降**：数据库成为瓶颈，响应时间变长
- **资源浪费**：CPU、内存、网络带宽被无效查询占用
- **服务不稳定**：严重时可能导致数据库崩溃，服务不可用

**示例**：
```
假设每秒有1000个请求查询不存在的用户ID
如果没有缓存保护，这1000个请求都会访问数据库
数据库每秒需要处理1000次无效查询
如果数据库QPS上限是5000，那么20%的资源被浪费在无效查询上
```

### 4. 解决方案

#### 方案1：空值缓存（Null Cache）

**原理**：将空结果也缓存起来，设置较短的过期时间。

**优点**：
- 实现简单，代码改动小
- 有效防止缓存穿透
- 适合大多数场景

**缺点**：
- 需要占用一定的缓存空间
- 如果数据后来被创建，需要及时清理空值缓存

**实现**：

```go
func GetUser(id int64) (*User, error) {
    // 1. 先查缓存
    val, err := cache.Get(fmt.Sprintf("user:%d", id))
    if err == nil {
        if val == "NULL" {
            // 空值缓存命中
            log.Printf("[空值缓存命中] user_id=%d", id)
            return nil, fmt.Errorf("用户不存在")
        }
        // 正常缓存命中
        var user User
        json.Unmarshal([]byte(val), &user)
        return &user, nil
    }
    
    // 2. 缓存未命中，查数据库
    user, err := db.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存
    if user == nil {
        // 空值缓存：设置短过期时间（60秒）
        cache.Set(fmt.Sprintf("user:%d", id), "NULL", 60)
        log.Printf("[空值缓存写入] user_id=%d, expire=60秒", id)
        return nil, fmt.Errorf("用户不存在")
    } else {
        // 正常缓存：设置长过期时间（5分钟）
        data, _ := json.Marshal(user)
        cache.Set(fmt.Sprintf("user:%d", id), string(data), 300)
        log.Printf("[正常缓存写入] user_id=%d, expire=300秒", id)
    }
    
    return user, nil
}
```

**注意事项**：
- 空值缓存的过期时间要短（如60秒），避免占用过多空间
- 正常数据的缓存过期时间可以长一些（如5分钟）
- 当数据被创建时，需要删除对应的空值缓存

#### 方案2：布隆过滤器（Bloom Filter）

**原理**：使用布隆过滤器在查询前判断数据是否存在。

**优点**：
- 内存占用小
- 查询速度快（O(1)）
- 适合数据量大、查询频繁的场景

**缺点**：
- 存在误判率（可能将存在的数据判断为不存在）
- 无法删除元素（需要重建过滤器）
- 实现相对复杂

**实现**：

```go
// 使用 Redis 的布隆过滤器（需要 Redis 4.0+）
func GetUser(id int64) (*User, error) {
    // 1. 先检查布隆过滤器
    exists, err := bloomFilter.Exists(fmt.Sprintf("user:%d", id))
    if err == nil && !exists {
        // 布隆过滤器判断不存在，直接返回
        log.Printf("[布隆过滤器拦截] user_id=%d 不存在", id)
        return nil, fmt.Errorf("用户不存在")
    }
    
    // 2. 布隆过滤器判断可能存在，继续查询缓存
    user, err := cache.GetUser(id)
    if err == nil && user != nil {
        return user, nil
    }
    
    // 3. 缓存未命中，查数据库
    user, err = db.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    // 4. 写入缓存和布隆过滤器
    if user == nil {
        // 数据不存在，不写入布隆过滤器（避免误判）
        return nil, fmt.Errorf("用户不存在")
    } else {
        // 数据存在，写入缓存和布隆过滤器
        cache.SetUser(user, 300)
        bloomFilter.Add(fmt.Sprintf("user:%d", id))
    }
    
    return user, nil
}
```

**使用 Redis 布隆过滤器**：

```bash
# Redis 4.0+ 支持布隆过滤器模块
# 安装：需要加载 redisbloom 模块

# 创建布隆过滤器
BF.RESERVE user_bf 0.01 1000000

# 添加元素
BF.ADD user_bf user:1

# 检查元素是否存在
BF.EXISTS user_bf user:1
```

#### 方案3：参数校验

**原理**：在应用层对查询参数进行校验，过滤掉明显无效的请求。

**实现**：

```go
func GetUser(id int64) (*User, error) {
    // 1. 参数校验
    if id <= 0 {
        return nil, fmt.Errorf("无效的用户ID")
    }
    
    // 2. 检查ID范围（如果知道ID范围）
    if id > 1000000 {
        return nil, fmt.Errorf("用户ID超出范围")
    }
    
    // 3. 继续正常查询流程
    // ...
}
```

**适用场景**：
- ID有明确的范围或格式
- 可以提前过滤掉明显无效的请求
- 作为第一道防线，配合其他方案使用

### 5. 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **空值缓存** | 实现简单，效果明显 | 占用缓存空间 | 大多数场景（推荐） |
| **布隆过滤器** | 内存占用小，查询快 | 有误判率，实现复杂 | 数据量大、查询频繁 |
| **参数校验** | 实现简单，成本低 | 只能过滤部分无效请求 | 作为辅助方案 |

### 6. 最佳实践

**推荐方案**：**空值缓存 + 参数校验**

```go
func GetUser(id int64) (*User, error) {
    // 1. 参数校验（第一道防线）
    if id <= 0 {
        return nil, fmt.Errorf("无效的用户ID")
    }
    
    // 2. 查询缓存（包括空值缓存）
    user, err := cache.GetUser(id)
    if err == nil {
        if user == nil {
            // 空值缓存命中
            return nil, fmt.Errorf("用户不存在")
        }
        return user, nil
    }
    
    // 3. 查询数据库
    user, err = db.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    // 4. 写入缓存（包括空值）
    if user == nil {
        cache.SetNull(id, 60)  // 空值缓存60秒
    } else {
        cache.SetUser(user, 300)  // 正常缓存5分钟
    }
    
    return user, nil
}
```

**关键要点**：
1. **空值缓存时间要短**：避免占用过多缓存空间
2. **正常缓存时间要长**：提高缓存命中率
3. **数据创建时清理空值缓存**：保证数据一致性
4. **监控缓存穿透情况**：及时发现和处理问题

### 7. 与缓存击穿、缓存雪崩的区别

| 问题 | 定义 | 原因 | 解决方案 |
|------|------|------|----------|
| **缓存穿透** | 查询不存在的数据 | 数据既不在缓存也不在数据库 | 空值缓存、布隆过滤器 |
| **缓存击穿** | 热点数据过期 | 热点数据缓存过期，大量请求访问数据库 | 分布式锁、永不过期 |
| **缓存雪崩** | 大量缓存同时过期 | 缓存过期时间设置相同 | 随机过期时间、双缓存 |

### 8. 实际应用

**参考代码**：
- `experiments/cache-demo/service/user_service.go:53` - 当前未处理缓存穿透
- 可以扩展为空值缓存方案

**监控指标**：
- 缓存穿透率 = 空值查询次数 / 总查询次数
- 数据库无效查询QPS
- 缓存命中率

**优化建议**：
- 设置合理的空值缓存过期时间
- 监控缓存穿透情况，及时调整策略
- 结合业务场景选择合适的方案