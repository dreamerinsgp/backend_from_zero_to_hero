录制：redis基础21_内存淘汰策略.mp4
日期：2026-01-30 22:46:49
录制文件：https://meeting.tencent.com/crm/23wyaAyV1f

Q1： 什么是内存淘汰？

## 面试回答（精简版）

**定义**：内存淘汰是当Redis内存使用达到上限（`maxmemory`）时，根据配置的淘汰策略自动删除一些key，为新数据腾出空间。

**核心概念**：
- **触发条件**：内存使用达到 `maxmemory` 限制
- **淘汰对象**：根据策略选择要删除的key
- **目的**：防止内存溢出，保证Redis服务可用

**示例**：
```
Redis内存限制：100MB
当前内存使用：100MB
新数据需要：10MB

→ 触发内存淘汰
→ 根据策略删除一些key，释放10MB空间
→ 写入新数据
```

---

## 详细说明

### 1. 内存淘汰的定义

**内存淘汰（Memory Eviction）**是Redis在内存使用达到上限时，根据配置的淘汰策略自动删除一些key，为新数据腾出空间的机制。

**关键特点**：
- **自动触发**：内存达到上限时自动执行
- **策略驱动**：根据配置的淘汰策略选择要删除的key
- **保证服务**：防止内存溢出，保证Redis服务可用

### 2. 内存淘汰的工作流程

```
1. 新数据写入请求
   ↓
2. 检查内存使用是否达到 maxmemory
   ├─ 否 → 直接写入
   └─ 是 → 触发内存淘汰
        ↓
3. 根据淘汰策略选择要删除的key
   ↓
4. 删除选中的key
   ↓
5. 释放内存空间
   ↓
6. 写入新数据
```

### 3. 内存淘汰的配置

**关键配置**：
- `maxmemory <bytes>`：设置内存上限
- `maxmemory-policy <policy>`：设置淘汰策略
- `maxmemory-samples <count>`：LRU/LFU采样数量（默认5）

**示例配置**：
```redis
# 设置内存上限为100MB
maxmemory 100mb

# 设置淘汰策略为 allkeys-lru
maxmemory-policy allkeys-lru

# LRU采样数量（提高精度，但增加CPU开销）
maxmemory-samples 5
```

---

Q2: 为什么会发生内存淘汰？

## 面试回答（精简版）

**原因**：Redis内存有限，当内存使用达到上限时，需要为新数据腾出空间。

**具体场景**：
1. **内存限制**：设置了 `maxmemory`，防止Redis占用过多内存
2. **内存不足**：新数据写入时，内存已满，无法分配空间
3. **保证服务**：如果不淘汰，新数据无法写入，服务不可用

**解决方案**：
- **内存淘汰**：删除一些key，释放空间
- **返回错误**：如果策略是 `noeviction`，返回错误

**示例**：
```
场景：Redis内存100MB，已使用100MB
问题：新数据需要10MB，但内存已满
解决：根据策略删除一些key，释放10MB空间
```

---

## 详细说明

### 1. 为什么会发生内存淘汰？

#### 1.1 内存限制

**原因**：Redis运行在内存中，内存是有限的资源。

**问题**：
- 如果不限制内存，Redis可能占用所有可用内存
- 导致系统内存不足，影响其他服务
- 可能导致系统OOM（Out Of Memory）kill进程

**解决方案**：
- 设置 `maxmemory` 限制Redis的最大内存使用
- 当内存达到上限时，触发内存淘汰

#### 1.2 内存不足

**场景**：新数据写入时，内存已满。

**问题**：
```
当前状态：
- 内存使用：100MB（达到上限）
- 新数据需要：10MB

问题：
- 无法为新数据分配内存
- 如果不淘汰，新数据无法写入
```

**解决方案**：
- **内存淘汰**：删除一些key，释放10MB空间
- **写入新数据**：使用释放的空间写入新数据

#### 1.3 保证服务可用性

**问题**：如果不淘汰，会发生什么？

**情况1：noeviction策略**
```
内存已满 → 新数据写入 → 返回错误
→ 服务不可用（无法写入新数据）
```

**情况2：有淘汰策略**
```
内存已满 → 触发淘汰 → 删除一些key → 释放空间
→ 写入新数据 → 服务可用
```

### 2. 内存淘汰的触发时机

**触发条件**：
1. **内存达到上限**：`used_memory >= maxmemory`
2. **新数据写入**：执行 `SET`、`LPUSH`、`HSET` 等写操作
3. **需要分配内存**：新数据需要分配内存空间

**不触发的情况**：
- 只读操作（`GET`、`HGET` 等）不会触发淘汰
- 内存未达到上限时不会触发

### 3. 内存淘汰的必要性

**为什么需要内存淘汰？**

1. **防止内存溢出**：
   - 限制Redis的内存使用
   - 防止占用过多系统内存

2. **保证服务可用**：
   - 允许新数据写入
   - 避免服务不可用

3. **自动管理**：
   - 不需要手动删除key
   - 根据策略自动选择要删除的key

---

Q3：redis常见的内存淘汰策略？

## 面试回答（精简版）

**8种淘汰策略**：

| 策略 | 作用范围 | 淘汰方式 | 适用场景 |
|------|----------|----------|----------|
| **volatile-lru** | 设置了过期时间的key | LRU（最近最少使用） | 缓存场景，保留热点数据 |
| **allkeys-lru** | 所有key | LRU（最近最少使用） | 通用缓存场景（推荐） |
| **volatile-lfu** | 设置了过期时间的key | LFU（最不经常使用） | 访问频率差异大的缓存 |
| **allkeys-lfu** | 所有key | LFU（最不经常使用） | 访问频率差异大的缓存 |
| **volatile-random** | 设置了过期时间的key | 随机 | 测试场景 |
| **allkeys-random** | 所有key | 随机 | 测试场景 |
| **volatile-ttl** | 设置了过期时间的key | TTL最小（即将过期） | 优先淘汰即将过期的数据 |
| **noeviction** | - | 不淘汰，返回错误 | 数据不能丢失的场景 |

**推荐策略**：
- **缓存场景**：`allkeys-lru`（推荐）
- **数据不能丢失**：`noeviction` + 持久化
- **访问频率差异大**：`allkeys-lfu`

**配置示例**：
```redis
maxmemory 100mb
maxmemory-policy allkeys-lru
```

---

## 详细说明

### 1. 淘汰策略分类

#### 1.1 按作用范围分类

**volatile-***：只淘汰设置了过期时间的key
- 只考虑有 `EXPIRE` 或 `TTL` 的key
- 永久key不会被淘汰

**allkeys-***：淘汰所有key
- 包括设置了过期时间的key和永久key
- 更灵活，但可能删除重要数据

#### 1.2 按淘汰算法分类

**LRU（Least Recently Used）**：最近最少使用
- 淘汰最久未访问的key
- 适合：访问模式有时间局部性

**LFU（Least Frequently Used）**：最不经常使用
- 淘汰访问频率最低的key
- 适合：访问频率差异大的场景

**Random**：随机
- 随机选择key删除
- 适合：测试场景

**TTL**：过期时间
- 淘汰TTL最小的key（即将过期）
- 适合：优先淘汰即将过期的数据

**noeviction**：不淘汰
- 不删除任何key，返回错误
- 适合：数据不能丢失的场景

### 2. 各策略详解

#### 2.1 volatile-lru

**定义**：从设置了过期时间的key中，使用LRU算法淘汰。

**工作原理**：
```
1. 只考虑设置了过期时间的key
2. 计算每个key的最后访问时间
3. 选择最久未访问的key删除
```

**适用场景**：
- 缓存场景
- 需要保留永久数据
- 热点数据访问频繁

**示例**：
```redis
# 设置了过期时间的key
SET user:1 "alice" EX 3600
SET user:2 "bob" EX 3600

# 永久key（不会被淘汰）
SET config:app "production"

# 内存满时，淘汰 user:1 或 user:2（最久未访问的）
```

#### 2.2 allkeys-lru（推荐）

**定义**：从所有key中，使用LRU算法淘汰。

**工作原理**：
```
1. 考虑所有key（包括永久key）
2. 计算每个key的最后访问时间
3. 选择最久未访问的key删除
```

**适用场景**：
- **通用缓存场景**（最常用）
- 不需要区分永久数据和临时数据
- 希望保留热点数据

**优势**：
- ✅ 简单易用
- ✅ 保留热点数据
- ✅ 适合大多数场景

**示例**：
```redis
# 所有key都可能被淘汰
SET user:1 "alice"
SET user:2 "bob"
SET config:app "production"

# 内存满时，淘汰最久未访问的key（可能是 user:1、user:2 或 config:app）
```

#### 2.3 volatile-lfu

**定义**：从设置了过期时间的key中，使用LFU算法淘汰。

**工作原理**：
```
1. 只考虑设置了过期时间的key
2. 统计每个key的访问频率
3. 选择访问频率最低的key删除
```

**适用场景**：
- 访问频率差异大的缓存
- 需要保留高频访问的数据
- 低频数据可以淘汰

**示例**：
```redis
# user:1 访问100次/天
# user:2 访问1次/天

# 内存满时，淘汰 user:2（访问频率低）
```

#### 2.4 allkeys-lfu

**定义**：从所有key中，使用LFU算法淘汰。

**工作原理**：
```
1. 考虑所有key
2. 统计每个key的访问频率
3. 选择访问频率最低的key删除
```

**适用场景**：
- 访问频率差异大的场景
- 需要保留高频访问的数据
- 低频数据可以淘汰

#### 2.5 volatile-random

**定义**：从设置了过期时间的key中，随机选择删除。

**工作原理**：
```
1. 只考虑设置了过期时间的key
2. 随机选择一个key删除
```

**适用场景**：
- 测试场景
- 不需要特定淘汰逻辑

**不推荐**：生产环境不建议使用

#### 2.6 allkeys-random

**定义**：从所有key中，随机选择删除。

**工作原理**：
```
1. 考虑所有key
2. 随机选择一个key删除
```

**适用场景**：
- 测试场景
- 不需要特定淘汰逻辑

**不推荐**：生产环境不建议使用

#### 2.7 volatile-ttl

**定义**：从设置了过期时间的key中，选择TTL最小的删除（即将过期）。

**工作原理**：
```
1. 只考虑设置了过期时间的key
2. 计算每个key的剩余TTL
3. 选择TTL最小的key删除（即将过期）
```

**适用场景**：
- 优先淘汰即将过期的数据
- 希望数据自然过期

**示例**：
```redis
SET user:1 "alice" EX 100  # TTL = 100秒
SET user:2 "bob" EX 3600   # TTL = 3600秒

# 内存满时，淘汰 user:1（TTL最小，即将过期）
```

#### 2.8 noeviction（默认）

**定义**：不淘汰任何key，当内存满时返回错误。

**工作原理**：
```
1. 内存达到上限
2. 新数据写入请求
3. 返回错误（不写入）
```

**适用场景**：
- **数据不能丢失**的场景
- 需要保证数据完整性
- 配合持久化使用

**注意事项**：
- ⚠️ 内存满时，写操作会返回错误
- ⚠️ 需要配合持久化（RDB/AOF）
- ⚠️ 需要监控内存使用，及时扩容

**示例**：
```redis
# 内存已满
SET new:key "value"
# 返回错误：(error) OOM command not allowed when used memory > 'maxmemory'
```

### 3. LRU vs LFU 对比

| 特性 | LRU | LFU |
|------|-----|-----|
| **判断标准** | 最后访问时间 | 访问频率 |
| **适合场景** | 访问模式有时间局部性 | 访问频率差异大 |
| **示例** | 最近访问的数据更可能再次访问 | 高频访问的数据应该保留 |
| **实现** | 记录最后访问时间 | 统计访问次数 |

**LRU示例**：
```
访问序列：A → B → C → A → D
淘汰：B（最久未访问）
```

**LFU示例**：
```
访问频率：A(100次) > B(50次) > C(1次)
淘汰：C（访问频率最低）
```

### 4. 策略选择建议

#### 4.1 缓存场景（推荐）

**推荐策略**：`allkeys-lru`

**原因**：
- 简单易用
- 保留热点数据
- 适合大多数缓存场景

**配置**：
```redis
maxmemory 100mb
maxmemory-policy allkeys-lru
```

#### 4.2 数据不能丢失

**推荐策略**：`noeviction` + 持久化

**原因**：
- 保证数据完整性
- 配合RDB/AOF持久化
- 需要监控内存使用

**配置**：
```redis
maxmemory 100mb
maxmemory-policy noeviction
save 900 1
appendonly yes
```

#### 4.3 访问频率差异大

**推荐策略**：`allkeys-lfu`

**原因**：
- 保留高频访问的数据
- 淘汰低频访问的数据
- 适合访问模式稳定的场景

**配置**：
```redis
maxmemory 100mb
maxmemory-policy allkeys-lfu
```

#### 4.4 优先淘汰即将过期的数据

**推荐策略**：`volatile-ttl`

**原因**：
- 优先淘汰即将过期的数据
- 让数据自然过期
- 适合有明确过期时间的场景

**配置**：
```redis
maxmemory 100mb
maxmemory-policy volatile-ttl
```

### 5. 配置示例

#### 5.1 基本配置

```redis
# 设置内存上限
maxmemory 100mb

# 设置淘汰策略
maxmemory-policy allkeys-lru

# LRU采样数量（提高精度，但增加CPU开销）
maxmemory-samples 5
```

#### 5.2 动态配置

```bash
# 使用 redis-cli 动态配置
redis-cli CONFIG SET maxmemory 200mb
redis-cli CONFIG SET maxmemory-policy allkeys-lru
```

#### 5.3 查看配置

```bash
# 查看当前配置
redis-cli CONFIG GET maxmemory
redis-cli CONFIG GET maxmemory-policy
redis-cli CONFIG GET maxmemory-samples
```

### 6. 注意事项

#### 6.1 采样数量

**maxmemory-samples**：
- 默认值：5
- 范围：1-64
- 作用：LRU/LFU算法的采样数量

**影响**：
- **值越大**：精度越高，但CPU开销越大
- **值越小**：速度越快，但精度越低

**建议**：
- 默认值5通常足够
- 如果需要更高精度，可以设置为10

#### 6.2 内存监控

**监控指标**：
- `used_memory`：当前内存使用
- `used_memory_peak`：内存使用峰值
- `maxmemory`：内存上限

**监控命令**：
```bash
redis-cli INFO memory
```

#### 6.3 淘汰性能

**影响**：
- 内存淘汰会消耗CPU资源
- 频繁淘汰可能影响性能

**优化**：
- 合理设置 `maxmemory`
- 选择合适的淘汰策略
- 监控淘汰频率

### 7. 总结

**8种淘汰策略**：

1. **volatile-lru**：设置了过期时间的key，LRU算法
2. **allkeys-lru**：所有key，LRU算法（推荐）
3. **volatile-lfu**：设置了过期时间的key，LFU算法
4. **allkeys-lfu**：所有key，LFU算法
5. **volatile-random**：设置了过期时间的key，随机
6. **allkeys-random**：所有key，随机
7. **volatile-ttl**：设置了过期时间的key，TTL最小
8. **noeviction**：不淘汰，返回错误

**选择建议**：
- **缓存场景**：`allkeys-lru`（推荐）
- **数据不能丢失**：`noeviction` + 持久化
- **访问频率差异大**：`allkeys-lfu`
- **优先淘汰即将过期**：`volatile-ttl`