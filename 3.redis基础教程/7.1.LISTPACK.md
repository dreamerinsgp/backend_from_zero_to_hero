录制：redis基础12_有序集合底层数据结构1_压缩链表.mp4
日期：2026-01-30 22:35:22
录制文件：https://meeting.tencent.com/crm/l6PrqBMe74

Q1: LISTPACK 数据结构
是Redis设计的一种内存高效的连续内存数据结构，用于替代ZIPLIST
1) 什么是LISTPACK?
是一个紧凑的，连续内存的数据结构，用于存储有序的元素列表。 

2）内存布局
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ total   │ numele  │ entry1  │ entry2  │ entry3  │  LP_EOF │
│ bytes   │         │ (变长)  │ (变长)  │ (变长)  │ (0xFF)  │
│ (4字节) │ (2字节) │         │         │         │ (1字节) │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
-total bytes: 整个LISTPACK占用的字节树 (4字节)
-num elements: 元素数量 
-entries: 实际的元素
-LP_EOF: 结束标记

3) 每个entry的结构
┌──────────┬──────────┬──────────┐
│ encoding │   data   │ backlen  │
│ (1-5字节)│ (变长)   │ (1-5字节)│
└──────────┴──────────┴──────────┘
- encoding: 编码方式 (1-5字节)，标识数据类型和长度
    - 整数编码:  7bit/13bit ...
    - 字符串编码： 6bit/12bit...
- data: 实际数据 (整数/字符串)


Q2: 它是如何实现按照分数升序存储的？
在sorted set中使用LISTPACK时，元素按分数从小到大有序排序的。 
1）存储格式
LISTPACK中存储的是 member-score 对，交替存储。 
LISTPACK 存储格式：
┌─────────────────────────────────────────────────────────┐
│ total │ num │ entry1 │ entry2 │ entry3 │ entry4 │ ... │ EOF │
│ bytes │ ele │ member │ score  │ member │ score  │     │     │
└─────────────────────────────────────────────────────────┘

示例：存储 [("Alice", 100), ("Charlie", 150), ("Bob", 200)]
┌─────────────────────────────────────────────────────────┐
│ total │ num │ "Alice" │ 100 │ "Charlie" │ 150 │ "Bob" │ 200 │ EOF │
└─────────────────────────────────────────────────────────┘
关键点
- 每个member后面紧跟着它的score
- 所有元素按score 从小到大排序
- member和score交替存储

2）插入操作（如何保持有序）
unsigned char *ZZlINsert(unsigned char *zl, sds ele, double score){
    unsigned char *eptr = lpSeek(zl,0); 
    double s;

    //遍历LISTPACK, 找到插入位置
    while(eptr !=NULL){
        sptr = lpNext(zl,eptr); //获取score
        s = zzlGetScore(sptr); //读取分数

        if (s > score){
            //找到第一个分数大于要插入分数的位置
            //在该位置前插入
            zl = zzllnsertAt(al,eptr,ele,score);
            break;
        }else if(s == score){
            //分数相同，按字典序排序
            if (zzlCompareElements(eptr, ele)>0) {
                zl = zzlInsertAt(zl,eptr,ele,score);
                break;
            }
        }
    }
    // 移动到下一个member;
    eptr = lpNext(zl,sptr);
}

//如果遍历完都没找到，插入到末尾
if (eptr == NULL)
    zl = zzlInsertAt(zl,NULL,ele,score);
return zl;
