录制：redis基础15_缓存更新策略.mp4
日期：2026-01-30 22:30:28
录制文件：https://meeting.tencent.com/crm/Kw3Magbn22


Q1： 缓存的更新策略

## 面试回答（精简版）

**核心策略：先更新数据库，再更新/删除缓存**

**两种更新方式**：

1. **更新缓存（Update Cache）**
   ```go
   db.Update(user)      // 1. 更新数据库
   cache.Set(user)      // 2. 更新缓存
   ```

2. **删除缓存（Delete Cache）**
   ```go
   db.Update(user)      // 1. 更新数据库
   cache.Delete(user)   // 2. 删除缓存，下次查询时重新加载
   ```

**选择原则**：

- **读多写少**：更新缓存（减少数据库查询）
- **写多读少**：删除缓存（避免频繁更新缓存）
- **数据一致性要求高**：删除缓存（保证数据最新）

**注意事项**：

- **顺序**：先更新数据库，再操作缓存（保证数据一致性）
- **容错**：缓存操作失败不影响业务逻辑
- **并发**：可能出现短暂不一致（可接受）

---

## 详细说明

### 1. 更新缓存 vs 删除缓存

#### 策略1：更新缓存（Update Cache）

**流程**：
```
更新数据库 → 更新缓存
```

**优点**：
- 下次查询直接命中缓存，性能好
- 减少数据库查询压力

**缺点**：
- 如果缓存更新失败，数据不一致
- 如果数据复杂，更新缓存成本高

**适用场景**：
- 读多写少
- 数据更新频率低
- 缓存数据结构简单

**代码示例**：
```go
func UpdateUser(user *User) error {
    // 1. 更新数据库
    if err := db.Update(user); err != nil {
        return err
    }
    
    // 2. 更新缓存
    if err := cache.Set(user); err != nil {
        log.Printf("缓存更新失败: %v", err)
        // 不影响业务逻辑
    }
    
    return nil
}
```

#### 策略2：删除缓存（Delete Cache）

**流程**：
```
更新数据库 → 删除缓存 → 下次查询时重新加载
```

**优点**：
- 保证数据一致性（下次查询时从数据库获取最新数据）
- 实现简单，避免复杂的缓存更新逻辑

**缺点**：
- 下次查询需要查数据库（缓存未命中）
- 如果更新频繁，缓存命中率低

**适用场景**：
- 写多读少
- 数据一致性要求高
- 缓存数据结构复杂（更新成本高）

**代码示例**：
```go
func UpdateUser(user *User) error {
    // 1. 更新数据库
    if err := db.Update(user); err != nil {
        return err
    }
    
    // 2. 删除缓存
    if err := cache.Delete(user.ID); err != nil {
        log.Printf("缓存删除失败: %v", err)
        // 不影响业务逻辑
    }
    
    return nil
}
```

### 2. 三种缓存模式

#### Cache-Aside（旁路缓存）- 最常用

**特点**：
- 应用程序负责维护缓存
- 查询时先查缓存，未命中查数据库

**更新流程**：
```
更新：数据库 → 缓存（更新或删除）
查询：缓存 → 数据库 → 缓存
```

**优点**：
- 实现简单
- 缓存失效不影响数据库
- 适合读多写少

**缺点**：
- 可能出现数据不一致
- 首次查询需要查数据库

#### Write-Through（写穿透）

**特点**：
- 先写缓存，再写数据库
- 保证缓存和数据库一致

**更新流程**：
```
更新：缓存 → 数据库（同步）
查询：缓存 → 返回
```

**优点**：
- 数据一致性高
- 查询性能好（缓存命中率高）

**缺点**：
- 写入性能低（需要写两次）
- 实现复杂

**适用场景**：
- 数据一致性要求极高
- 写操作较少

#### Write-Back（写回）

**特点**：
- 先写缓存，异步写数据库
- 写入性能高

**更新流程**：
```
更新：缓存 → 返回 → 异步写数据库
查询：缓存 → 返回
```

**优点**：
- 写入性能极高
- 适合高并发写入场景

**缺点**：
- 可能丢失数据（缓存未写入数据库时宕机）
- 实现复杂（需要异步队列）

**适用场景**：
- 写入频率极高
- 可以容忍少量数据丢失

### 3. 数据一致性问题

#### 问题1：更新顺序

**错误做法**：
```go
cache.Set(user)  // 先更新缓存
db.Update(user)  // 后更新数据库
// 如果数据库更新失败，缓存和数据库不一致
```

**正确做法**：
```go
db.Update(user)  // 先更新数据库
cache.Set(user)  // 后更新缓存
// 即使缓存更新失败，数据库也是最新的
```

#### 问题2：并发更新

**场景**：
```
线程A：更新数据库 → 更新缓存（进行中）
线程B：更新数据库 → 更新缓存（进行中）
```

**结果**：可能出现缓存覆盖，最终缓存可能不是最新值

**解决方案**：
- 使用分布式锁
- 删除缓存（让下次查询重新加载）
- 接受短暂不一致（最终一致性）

### 4. 实际应用场景

#### 场景1：用户信息更新（更新缓存）

```go
// 读多写少，更新缓存
func UpdateUser(user *User) error {
    db.Update(user)
    cache.Set(user, 300)  // 更新缓存，5分钟过期
    return nil
}
```

#### 场景2：商品库存更新（删除缓存）

```go
// 写多读少，删除缓存
func UpdateStock(productID int64, stock int) error {
    db.UpdateStock(productID, stock)
    cache.Delete(fmt.Sprintf("product:%d", productID))  // 删除缓存
    return nil
}
```

#### 场景3：配置信息更新（删除缓存）

```go
// 数据一致性要求高，删除缓存
func UpdateConfig(key string, value string) error {
    db.UpdateConfig(key, value)
    cache.Delete(fmt.Sprintf("config:%s", key))  // 删除缓存
    return nil
}
```

### 5. 最佳实践

**原则1：先更新数据库，再操作缓存**
- 保证数据源（数据库）的准确性
- 缓存操作失败不影响业务

**原则2：根据场景选择策略**
- 读多写少 → 更新缓存
- 写多读少 → 删除缓存
- 一致性要求高 → 删除缓存

**原则3：设置合理的过期时间**
- 避免数据长期不一致
- 热点数据：较长过期时间
- 实时数据：较短过期时间

**原则4：容错处理**
- 缓存操作失败不影响业务逻辑
- 记录日志，便于排查问题

**原则5：考虑并发场景**
- 使用分布式锁（如果需要强一致性）
- 接受最终一致性（大多数场景）

### 6. 项目中的实际应用

**参考代码**：
- `experiments/cache-demo/service/user_service.go:85` - 更新缓存策略
- `experiments/cache-demo/service/user_service.go:106` - 删除缓存策略

**总结**：
- **更新缓存**：适合读多写少，减少数据库查询
- **删除缓存**：适合写多读少，保证数据一致性
- **先更新数据库**：保证数据源准确性
- **容错处理**：缓存失败不影响业务