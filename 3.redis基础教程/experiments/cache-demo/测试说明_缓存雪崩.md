# 缓存雪崩问题测试说明

## 概述

本测试程序演示了缓存雪崩问题及其解决方案（随机过期时间），帮助理解缓存雪崩的危害和如何通过随机过期时间来平滑数据库压力。

## 什么是缓存雪崩？

**缓存雪崩（Cache Avalanche）**是指大量缓存数据在同一时间过期，导致大量请求同时访问数据库，瞬间造成数据库压力暴增甚至崩溃。

**关键特征**：
- **时间集中**：大量缓存在同一时刻过期
- **请求集中**：大量请求同时穿透缓存
- **压力集中**：数据库瞬间压力暴增

## 运行测试

```bash
# 确保数据库和Redis已启动
# 确保测试数据已初始化（至少10个用户）
go run main.go init-db

# 运行缓存雪崩测试
go run test_cache_avalanche.go

# 或者使用编译后的可执行文件
./test_cache_avalanche
```

**注意**：测试使用60秒的过期时间便于观察，实际运行需要等待60秒让缓存过期。

## 测试场景详解

### 场景1：缓存雪崩问题演示

**目的**：展示缓存雪崩问题的危害

**测试流程**：
1. **批量加载**：加载10个用户到缓存，都设置60秒固定过期时间
2. **等待过期**：等待60秒，所有缓存同时过期
3. **并发查询**：模拟100个并发请求查询这些用户
4. **观察结果**：统计数据库访问次数和QPS峰值

**预期结果**：
- 所有缓存在同一时刻过期
- 100个请求同时访问数据库
- 数据库QPS峰值非常高（接近100）
- 数据库压力暴增

**关键代码**：
```go
// 使用固定过期时间
userCache.SetUserWithFixedExpire(user, 60)  // 都是60秒

// 等待60秒后，所有缓存同时过期
time.Sleep(60 * time.Second)

// 100个并发请求同时查询
// → 100个请求同时访问数据库（雪崩）
```

### 场景2：随机过期时间解决方案

**目的**：展示如何使用随机过期时间解决缓存雪崩问题

**测试流程**：
1. **批量加载**：加载10个用户到缓存，设置60-66秒随机过期时间
2. **等待过期**：等待60秒后，缓存开始陆续过期（不是同时过期）
3. **并发查询**：模拟100个并发请求查询这些用户
4. **观察结果**：统计数据库访问次数和QPS峰值

**预期结果**：
- 缓存过期时间分散（60-66秒随机）
- 数据库访问分散，不会同时访问
- 数据库QPS峰值较低（平滑）
- 数据库压力平滑

**关键代码**：
```go
// 使用随机过期时间
userCache.SetUserWithRandomExpire(user, 60)  // 60-66秒随机

// 等待60秒后，缓存开始陆续过期
time.Sleep(60 * time.Second)

// 100个并发请求查询
// → 数据库访问分散，不会同时访问
```

### 场景3：效果对比

**目的**：对比使用固定过期时间和随机过期时间的效果

**测试流程**：
1. **测试1**：固定过期时间，50个并发请求
   - 记录数据库访问次数和QPS峰值
2. **测试2**：随机过期时间，50个并发请求
   - 记录数据库访问次数和QPS峰值
3. **对比分析**：对比两种方案的数据库QPS峰值

**预期结果**：
- 固定过期时间：QPS峰值高（接近50）
- 随机过期时间：QPS峰值低（平滑）
- QPS峰值减少显著（可能减少50%以上）

## 代码实现

### 1. 随机过期时间实现 (`cache/user_cache_avalanche.go`)

**关键特性**：
- `SetUserWithRandomExpire()`: 设置随机过期时间
- `SetUserWithFixedExpire()`: 设置固定过期时间（用于对比）
- 随机算法：基础过期时间 + 随机值（0-10%范围）

**随机过期时间算法**：
```go
baseExpire := 60  // 基础过期时间60秒
randomRange := baseExpire * 10 / 100  // 随机范围6秒（10%）
randomExpire := rand.Intn(randomRange)  // 0-6秒随机
expire := baseExpire + randomExpire  // 60-66秒随机
```

### 2. 服务层实现 (`service/user_service_avalanche.go`)

**关键逻辑**：
```go
// 支持两种模式
type ExpireMode int
const (
    FixedExpire ExpireMode = iota   // 固定过期时间（模拟雪崩）
    RandomExpire                    // 随机过期时间（解决雪崩）
)

// 根据模式选择过期时间策略
switch mode {
case FixedExpire:
    cache.SetUserWithFixedExpire(user, baseExpire)
case RandomExpire:
    cache.SetUserWithRandomExpire(user, baseExpire)
}
```

### 3. 数据库查询统计 (`test_cache_avalanche.go`)

**统计功能**：
- `DBQueryStats`: 统计数据库查询次数和时间
- `GetQPSInWindow()`: 计算指定时间窗口内的QPS
- 记录每次查询的时间戳，用于分析QPS分布

## 关键要点

### 1. 随机过期时间的优势

- **分散过期时间**：避免缓存在同一时刻过期
- **平滑数据库压力**：数据库访问分散，不会同时访问
- **实现简单**：代码改动小，效果明显

### 2. 随机范围的选择

**推荐范围**：基础过期时间的5%-10%

```go
// 示例：基础过期时间1小时
baseExpire := 3600  // 1小时
randomRange := 360  // 6分钟（10%）
expire := 3600 + rand.Intn(360)  // 3600-3960秒随机
```

**选择原则**：
- 范围太小：效果不明显
- 范围太大：缓存过期时间差异过大，可能影响业务
- 推荐：5%-10%的基础过期时间

### 3. 测试注意事项

1. **过期时间设置**：使用60秒便于测试观察（实际生产环境通常更长）
2. **并发请求数**：使用100个并发请求模拟真实场景
3. **等待时间**：需要等待缓存过期才能观察到效果
4. **测试数据**：确保至少有10个用户用于测试

### 4. 与其他方案的对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **随机过期时间** | 实现简单，效果明显 | 无法完全避免 | 大多数场景（推荐） |
| **双缓存策略** | 保证可用性 | 实现复杂，内存占用大 | 高可用性要求 |
| **缓存预热** | 提高命中率 | 需要识别热点数据 | 热点数据场景 |
| **限流降级** | 保护数据库 | 可能影响用户体验 | 高并发场景 |

## 实际应用

**参考代码**：
- `cache/user_cache_avalanche.go` - 随机过期时间缓存层
- `service/user_service_avalanche.go` - 支持随机过期时间的服务层
- `test_cache_avalanche.go` - 测试程序

**监控指标**：
- 缓存过期时间分布
- 数据库QPS峰值
- 缓存命中率
- 服务可用性

**优化建议**：
1. **设置随机过期时间**：基础过期时间 + 随机值（5%-10%）
2. **监控缓存过期情况**：及时发现缓存雪崩风险
3. **合理设置过期时间**：根据数据更新频率设置
4. **组合使用多种方案**：随机过期时间 + 双缓存 + 限流

## 总结

**缓存雪崩**是大量缓存在同一时间过期导致的问题，可以通过以下方式解决：

1. **随机过期时间**（推荐）：简单有效，适合大多数场景
2. **双缓存策略**：保证可用性，适合高可用性要求
3. **缓存预热**：提高命中率，适合热点数据场景
4. **限流降级**：保护数据库，适合高并发场景

**关键要点**：
- 避免大量缓存在同一时间过期
- 使用随机过期时间分散过期时间
- 监控缓存过期情况，及时发现问题
- 组合使用多种方案提高系统稳定性

## 参考文档

- [缓存雪崩优化详解](../../12.缓存雪崩优化.md)
- [缓存基本用法](../../8.缓存的用法.md)
