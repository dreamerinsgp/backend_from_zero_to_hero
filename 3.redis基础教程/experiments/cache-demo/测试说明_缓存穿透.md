# 缓存穿透问题测试说明

## 概述

本测试程序演示了缓存穿透问题及其解决方案（空值缓存），帮助理解缓存穿透的危害和如何通过空值缓存来解决。

## 什么是缓存穿透？

**缓存穿透**是指查询一个**根本不存在的数据**，导致：
- 缓存中查不到（未命中）
- 数据库中也没有（查询结果为空）
- 每次查询都直接访问数据库
- 无法缓存空结果，形成恶性循环

## 运行测试

```bash
# 确保数据库和Redis已启动
# 确保测试数据已初始化
go run main.go init-db

# 运行缓存穿透测试
go run test_cache_penetration.go

# 或者使用编译后的可执行文件
./test_cache_penetration
```

## 测试场景详解

### 场景1：缓存穿透问题演示

**目的**：展示缓存穿透问题的危害

**测试流程**：
1. 查询不存在的用户ID（如：99999）
2. 缓存未命中，查询数据库
3. 数据库返回空结果，但没有缓存
4. 再次查询相同的ID，仍然会查询数据库
5. 每次查询都访问数据库，造成数据库压力

**预期结果**：
- 每次查询都会访问数据库
- 数据库压力持续增加
- 系统性能下降

**关键代码**：
```go
// 使用普通的缓存服务（不支持空值缓存）
userCache := cache.NewUserCache(rds)
userService := service.NewUserService(repo, userCache)

// 查询不存在的用户
user, err := userService.GetUserByID(99999)
// 每次查询都会访问数据库
```

### 场景2：空值缓存解决方案

**目的**：展示如何使用空值缓存解决缓存穿透问题

**测试流程**：
1. 查询不存在的用户ID（如：88888）
2. 缓存未命中，查询数据库
3. 数据库返回空结果，**设置空值缓存**（60秒过期）
4. 再次查询相同的ID，**空值缓存命中**，不查询数据库
5. 后续查询都命中空值缓存，保护数据库

**预期结果**：
- 第1次查询：访问数据库，设置空值缓存
- 第2次查询：空值缓存命中，不访问数据库
- 第3次查询：空值缓存命中，不访问数据库
- 性能显著提升

**关键代码**：
```go
// 使用支持空值缓存的缓存服务
userCache := cache.NewUserCacheWithPenetration(rds)
userService := service.NewUserServiceWithPenetration(repo, userCache)

// 查询不存在的用户
user, err := userService.GetUserByID(88888)
// 第1次查询数据库，设置空值缓存
// 后续查询命中空值缓存，不查询数据库
```

### 场景3：空值缓存效果对比

**目的**：对比使用空值缓存前后的效果

**测试流程**：
1. **测试1**：不使用空值缓存，查询5次不存在的用户ID
   - 记录数据库访问次数
2. **测试2**：使用空值缓存，查询5次不存在的用户ID
   - 记录数据库访问次数
3. 对比两种方案的数据库访问次数

**预期结果**：
- 不使用空值缓存：5次查询，5次数据库访问
- 使用空值缓存：5次查询，1次数据库访问
- 数据库压力减少80%

## 代码实现

### 1. 空值缓存实现 (`cache/user_cache_penetration.go`)

**关键特性**：
- `SetNullUser(id)`: 设置空值缓存
- `GetUser(id)`: 支持识别空值缓存
- `ErrNullCache`: 空值缓存错误标识

**空值缓存标记**：
```go
const (
    NullCacheValue = "NULL"              // 空值缓存的标记值
    NullCacheExpireSeconds = 60          // 空值缓存过期时间（60秒）
)
```

### 2. 服务层实现 (`service/user_service_penetration.go`)

**关键逻辑**：
```go
func (s *userServiceWithPenetration) GetUserByID(id int64) (*model.User, error) {
    // 1. 先查缓存
    user, err := s.cache.GetUser(id)
    if err == nil && user != nil {
        return user, nil  // 正常缓存命中
    }
    
    // 2. 检查是否是空值缓存
    if errors.Is(err, cache.ErrNullCache) {
        return nil, fmt.Errorf("用户不存在")  // 空值缓存命中
    }
    
    // 3. 缓存未命中，查数据库
    user, err = s.repo.FindByID(id)
    if user == nil {
        // 4. 用户不存在，设置空值缓存
        s.cache.SetNullUser(id)
        return nil, fmt.Errorf("用户不存在")
    }
    
    // 5. 用户存在，写入正常缓存
    s.cache.SetUser(user, cache.DefaultExpireSeconds)
    return user, nil
}
```

## 关键要点

### 1. 空值缓存过期时间

- **建议设置较短**：60秒（避免占用过多缓存空间）
- **正常缓存过期时间**：5分钟（提高缓存命中率）

### 2. 数据创建时的处理

当数据被创建时，需要删除对应的空值缓存：

```go
func (s *userServiceWithPenetration) CreateUser(user *model.User) error {
    // 创建用户
    s.repo.Create(user)
    
    // 如果之前有空值缓存，需要删除
    s.cache.DeleteUser(user.ID)
    
    return nil
}
```

### 3. 监控指标

- **缓存穿透率** = 空值查询次数 / 总查询次数
- **数据库无效查询QPS**
- **空值缓存命中率**

## 最佳实践

1. **空值缓存时间要短**：避免占用过多缓存空间
2. **正常缓存时间要长**：提高缓存命中率
3. **数据创建时清理空值缓存**：保证数据一致性
4. **监控缓存穿透情况**：及时发现和处理问题

## 与其他问题的区别

| 问题 | 定义 | 原因 | 解决方案 |
|------|------|------|----------|
| **缓存穿透** | 查询不存在的数据 | 数据既不在缓存也不在数据库 | 空值缓存、布隆过滤器 |
| **缓存击穿** | 热点数据过期 | 热点数据缓存过期，大量请求访问数据库 | 分布式锁、永不过期 |
| **缓存雪崩** | 大量缓存同时过期 | 缓存过期时间设置相同 | 随机过期时间、双缓存 |

## 参考文档

- [缓存穿透问题详解](../../10.缓存穿透问题.md)
- [缓存基本用法](../../8.缓存的用法.md)
