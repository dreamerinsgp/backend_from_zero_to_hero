# 分布式锁对比实验说明

## 目的

通过对比实验，直观展示：
1. **普通锁（mutex）的问题**：无法跨进程控制，导致数据不一致
2. **分布式锁的解决方案**：可以跨进程/跨服务器控制，保证数据一致性
3. **不需要两台物理服务器**：可以通过**单机多进程**来模拟分布式锁的效果

## 实验文件

- `lock-demo/test_local_lock.go` - 实验1：多进程普通锁（mutex）- 展示问题
- `lock-demo/test_distributed_lock.go` - 实验2：多进程分布式锁 - 正确解决方案
- `run_lock_comparison.sh` - 对比实验脚本（推荐使用）

## 快速开始（推荐）

### 使用对比实验脚本（最简单）

```bash
cd /home/ubuntu/dex_full/web3fun-Dex/1.基础篇/3.redis基础教程/experiments/cache-demo

# 运行对比实验（包含实验1和实验2）
./run_lock_comparison.sh 3

# 或者单独运行某个实验
./run_lock_comparison.sh 1  # 实验1：普通锁
./run_lock_comparison.sh 2  # 实验2：分布式锁
```

脚本会自动：
- ✅ 检查Redis是否运行
- ✅ 重置库存为100
- ✅ 启动多个进程
- ✅ 显示最终库存和对比结果

## 手动运行方式

### 方法1：单机多进程（推荐）

**步骤**：

1. **确保Redis运行**：
   ```bash
   redis-cli ping
   # 应该返回 PONG
   ```

2. **打开多个终端窗口**，在每个终端运行：
   ```bash
   # 终端1
   cd /home/ubuntu/dex_full/web3fun-Dex/1.基础篇/3.redis基础教程/experiments/cache-demo
   go run test_distributed_lock.go 进程A
   
   # 终端2（新开一个终端）
   go run test_distributed_lock.go 进程B
   
   # 终端3（新开一个终端）
   go run test_distributed_lock.go 进程C
   ```

3. **观察效果**：
   - 只有一个进程能获取锁
   - 其他进程等待锁释放
   - 锁释放后，下一个进程获取锁

### 方法2：后台运行多个进程

```bash
# 启动多个后台进程
go run test_distributed_lock.go 进程1 &
go run test_distributed_lock.go 进程2 &
go run test_distributed_lock.go 进程3 &

# 查看所有进程的输出
wait
```

### 方法3：使用脚本批量启动

创建 `run_multiple_processes.sh`：

```bash
#!/bin/bash

for i in {1..5}; do
    echo "启动进程 $i"
    go run test_distributed_lock.go "进程-$i" &
done

wait
echo "所有进程完成"
```

运行：
```bash
chmod +x run_multiple_processes.sh
./run_multiple_processes.sh
```

## 对比实验说明

### 实验1：多进程普通锁（mutex）- 展示问题

**文件**：`test_local_lock.go`

**目的**：展示普通锁（mutex）无法跨进程控制的问题

**运行方式**：
```bash
cd lock-demo

# 终端1
go run test_local_lock.go 进程A

# 终端2（新开终端）
go run test_local_lock.go 进程B

# 终端3（新开终端）
go run test_local_lock.go 进程C
```

**预期效果**：
- ❌ 每个进程都有自己独立的 `sync.Mutex`
- ❌ 多个进程可以同时获取各自的锁
- ❌ 多个进程同时读取到相同的库存值（如100）
- ❌ 每个进程都扣减10，最终库存可能是70（应该是70，但如果同时读取，可能更少）
- ❌ **导致超卖问题！**

**输出示例**：
```
【实验1】多进程普通锁（mutex）- 展示问题
进程A 启动 (PID: 12345)
⚠️  注意：普通锁（mutex）只能控制单进程内的线程，无法跨进程控制！

进程A: 📦 当前库存: 100
进程A: 🛒 尝试购买 10 件商品...
进程A: 🔒 获取本地锁（mutex）...
进程A: ✅ 获取本地锁成功（但其他进程的锁是独立的！）
进程A: 📖 重新读取库存: 100
进程A: ✅ 扣减库存: 100 - 10 = 90

进程B: 📦 当前库存: 100  ← 问题：读取到旧值！
进程B: 🛒 尝试购买 10 件商品...
进程B: 🔒 获取本地锁（mutex）...
进程B: ✅ 获取本地锁成功（但其他进程的锁是独立的！）
进程B: 📖 重新读取库存: 100  ← 问题：还是旧值！
进程B: ✅ 扣减库存: 100 - 10 = 90  ← 超卖！应该是80

⚠️  问题分析：
   1. 每个进程都有自己独立的 mutex，互不影响
   2. 多个进程可以同时获取各自的锁
   3. 导致多个进程同时读取到相同的库存值
   4. 最终导致超卖问题！
```

### 实验2：多进程分布式锁 - 正确解决方案

**文件**：`test_distributed_lock.go`

**目的**：展示分布式锁如何正确解决跨进程控制问题

**运行方式**：
```bash
cd lock-demo

# 终端1
go run test_distributed_lock.go 进程A

# 终端2（新开终端）
go run test_distributed_lock.go 进程B

# 终端3（新开终端）
go run test_distributed_lock.go 进程C
```

**预期效果**：
- ✅ 所有进程共享同一个Redis分布式锁
- ✅ 同一时刻只有一个进程能获取锁
- ✅ 其他进程必须等待锁释放
- ✅ 每个进程按顺序读取和扣减库存
- ✅ **防止超卖问题！**

**输出示例**：
```
【实验2】多进程分布式锁 - 正确解决方案
进程A 启动 (PID: 12345)
✅ 分布式锁可以跨进程/跨服务器控制，所有进程共享同一个锁！

进程A: 📦 当前库存: 100
进程A: 🛒 尝试购买 10 件商品...
进程A: 🔒 尝试获取分布式锁 'lock:stock:product:1001'...
进程A: ✅ 获取分布式锁成功
进程A: 📖 重新读取库存: 100
进程A: ✅ 扣减库存: 100 - 10 = 90
进程A: 🔓 释放分布式锁

进程B: 📦 当前库存: 100
进程B: 🛒 尝试购买 10 件商品...
进程B: 🔒 尝试获取分布式锁 'lock:stock:product:1001'...
进程B: ⏳ 获取锁失败（锁已被其他进程持有），等待中...
进程B: ✅ 获取分布式锁成功（等待了 2 秒）
进程B: 📖 重新读取库存: 90  ← 正确：读取到最新值！
进程B: ✅ 扣减库存: 90 - 10 = 80

✅ 优势分析：
   1. 所有进程共享同一个Redis锁
   2. 同一时刻只有一个进程能获取锁
   3. 其他进程必须等待锁释放
   4. 有效防止超卖问题！
```

### 对比实验：同时运行两个实验

**使用脚本**：
```bash
./run_lock_comparison.sh 3
```

**对比结果**：

| 实验 | 锁类型 | 最终库存 | 问题 |
|------|--------|----------|------|
| **实验1** | 普通锁（mutex） | 70-90（不确定） | ❌ 超卖，数据不一致 |
| **实验2** | 分布式锁 | 70（正确） | ✅ 顺序执行，数据一致 |

**分析**：
- **实验1**：3个进程各购买10件，如果同时读取库存100，可能都扣减10，最终库存可能是70（正确）或更少（如果同时操作）
- **实验2**：3个进程按顺序执行，100 → 90 → 80 → 70，最终库存70（正确）

## 详细演示场景

### 场景1：基本锁获取和释放

**目的**：演示分布式锁的互斥性

**效果**：
- 多个进程同时尝试获取同一个锁
- 只有一个进程能成功获取锁
- 其他进程等待锁释放
- 锁释放后，下一个进程获取锁

**输出示例**：
```
================================================================================
进程A 启动 (PID: 12345)
================================================================================

【场景1】基本锁获取和释放
--------------------------------------------------------------------------------
进程A: 尝试获取锁 'lock:demo:test'...
进程A: ✅ 获取锁成功
进程A: 🔨 开始执行业务逻辑（模拟耗时操作）...
进程A:   执行步骤 1/5...
进程A:   执行步骤 2/5...
进程A:   执行步骤 3/5...
进程A:   执行步骤 4/5...
进程A:   执行步骤 5/5...
进程A: ✅ 业务逻辑执行完成
进程A: 🔓 释放锁
```

### 场景2：库存扣减模拟（防止超卖）

**目的**：演示分布式锁在实际业务中的应用

**效果**：
- 多个进程同时尝试扣减库存
- 使用分布式锁确保同一时刻只有一个进程能操作库存
- 防止超卖问题

**输出示例**：
```
【场景2】库存扣减模拟（防止超卖）
--------------------------------------------------------------------------------
进程A: 初始化库存: product:1001 = 100
进程A: 当前库存: 100
进程A: 尝试购买 10 件商品...
进程A: 尝试获取库存锁 'lock:stock:product:1001'...
进程A: ✅ 获取库存锁成功
进程A: 重新读取库存: 100
进程A: ✅ 扣减库存成功（100 - 10 = 90）
```

## 关键观察点

### 实验1（普通锁）的观察点：

1. **独立锁**：
   - 观察每个进程都能获取自己的锁（互不影响）
   - 多个进程可以同时执行

2. **数据不一致**：
   - 观察多个进程读取到相同的库存值
   - 观察最终库存可能不正确

3. **超卖问题**：
   - 观察多个进程同时扣减库存，导致超卖

### 实验2（分布式锁）的观察点：

1. **互斥性**：
   - 观察多个进程的输出，确认同一时刻只有一个进程能获取锁

2. **等待机制**：
   - 观察其他进程如何等待锁释放

3. **锁释放**：
   - 观察锁释放后，下一个进程如何获取锁

4. **库存扣减**：
   - 观察多个进程按顺序扣减库存，防止超卖
   - 观察最终库存正确（100 - 10 - 10 - 10 = 70）

## 对比：普通锁 vs 分布式锁

### 代码对比

#### 实验1：普通锁（mutex）

```go
// ❌ 错误：每个进程都有独立的mutex
var mu sync.Mutex

func DeductStock() {
    mu.Lock()  // 只能锁住当前进程内的线程
    // 读取库存
    stock := getStock()
    // 扣减库存
    updateStock(stock - quantity)
    mu.Unlock()
}
```

**问题**：
- 每个进程都有自己独立的 `sync.Mutex`
- 进程A的锁不影响进程B
- 多个进程可以同时执行，导致数据不一致

#### 实验2：分布式锁

```go
// ✅ 正确：所有进程共享同一个Redis锁
func DeductStock() {
    lock, ok, err := Lock(ctx, redis, "lock:stock:product:1001", 10)
    if !ok {
        // 等待锁释放
        return
    }
    defer ReleaseLock(lock)
    
    // 读取库存
    stock := getStock()
    // 扣减库存
    updateStock(stock - quantity)
}
```

**优势**：
- 所有进程共享同一个Redis锁
- 同一时刻只有一个进程能获取锁
- 其他进程必须等待，保证数据一致性

### 执行流程对比

#### 实验1：普通锁（mutex）

```
时间线：
T1: 进程A 获取本地锁（mutex）✅
T2: 进程B 获取本地锁（mutex）✅  ← 问题：独立锁，不影响进程A！
T3: 进程C 获取本地锁（mutex）✅  ← 问题：独立锁，不影响进程A和B！
T4: 进程A 读取库存 = 100
T5: 进程B 读取库存 = 100  ← 问题：读取到旧值！
T6: 进程C 读取库存 = 100  ← 问题：读取到旧值！
T7: 进程A 扣减10，库存 = 90
T8: 进程B 扣减10，库存 = 90  ← 超卖！应该是80
T9: 进程C 扣减10，库存 = 90  ← 超卖！应该是70

结果：最终库存 = 90（错误！应该是70）
```

#### 实验2：分布式锁

```
时间线：
T1: 进程A 获取分布式锁（Redis）✅
T2: 进程B 尝试获取分布式锁（Redis）❌ 等待...
T3: 进程C 尝试获取分布式锁（Redis）❌ 等待...
T4: 进程A 读取库存 = 100
T5: 进程A 扣减10，库存 = 90
T6: 进程A 释放分布式锁
T7: 进程B 获取分布式锁（Redis）✅
T8: 进程B 读取库存 = 90  ← 正确：读取到最新值！
T9: 进程B 扣减10，库存 = 80
T10: 进程B 释放分布式锁
T11: 进程C 获取分布式锁（Redis）✅
T12: 进程C 读取库存 = 80  ← 正确：读取到最新值！
T13: 进程C 扣减10，库存 = 70
T14: 进程C 释放分布式锁

结果：最终库存 = 70（正确！）
```

## 常见问题

### Q1: 为什么不需要两台物理服务器？

**A**: 分布式锁的核心是**跨进程/跨服务器**的互斥控制。在同一台机器上运行多个进程，每个进程都是独立的，它们通过Redis共享同一个锁，就能模拟分布式环境的效果。

### Q2: 单机多进程和单机多线程有什么区别？

**A**: 
- **多线程**：在同一个进程内，普通锁（mutex）就能控制
- **多进程**：每个进程是独立的，普通锁无法跨进程控制，需要分布式锁

### Q3: 如何验证分布式锁真的有效？

**A**: 
1. 同时运行多个进程
2. 观察输出，确认同一时刻只有一个进程能获取锁
3. 观察库存扣减，确认不会超卖

## 总结

- ✅ **不需要两台物理服务器**
- ✅ **单机多进程即可模拟分布式锁效果**
- ✅ **Redis作为锁服务，所有进程共享**
- ✅ **真实模拟分布式环境下的互斥控制**
