# 内存淘汰策略实验说明

## 目的

通过实际实验，演示不同内存淘汰策略的行为，观察：
1. 如何设置内存限制和淘汰策略
2. 如何触发内存淘汰
3. 不同策略下哪些key被淘汰
4. 各策略的差异和特点

## 快速开始

### 前置条件

1. **确保Redis运行**：
   ```bash
   redis-cli ping
   # 应该返回 PONG
   ```

2. **检查Redis版本**（建议6.0+）：
   ```bash
   redis-cli INFO server | grep redis_version
   ```

### 方法1：使用脚本（推荐）

```bash
cd /home/ubuntu/dex_full/web3fun-Dex/1.基础篇/3.redis基础教程/experiments/cache-demo

# 测试单个策略
./run_eviction_test.sh allkeys-lru

# 测试所有策略（对比）
./run_eviction_test.sh all
```

**注意**：
- 脚本会自动检查Redis是否运行
- 测试会修改Redis配置（maxmemory和maxmemory-policy）
- 测试结束后，建议恢复原始配置

### 方法2：直接运行

```bash
cd /home/ubuntu/dex_full/web3fun-Dex/1.基础篇/3.redis基础教程/experiments/cache-demo

# 测试单个策略
go run test_eviction_policy.go allkeys-lru

# 查看支持的策略
go run test_eviction_policy.go
```

## 支持的策略

- `allkeys-lru` - 所有key，LRU算法（推荐）
- `volatile-lru` - 设置了过期时间的key，LRU算法
- `allkeys-lfu` - 所有key，LFU算法
- `volatile-lfu` - 设置了过期时间的key，LFU算法
- `allkeys-random` - 所有key，随机
- `volatile-random` - 设置了过期时间的key，随机
- `volatile-ttl` - 设置了过期时间的key，TTL最小
- `noeviction` - 不淘汰，返回错误

## 实验流程

### 步骤1：清理测试数据

- 清空Redis中的所有数据
- 确保测试环境干净

### 步骤2：设置内存限制和淘汰策略

- 设置 `maxmemory = 5MB`（较小的值，便于测试）
- 设置 `maxmemory-policy = <策略>`
- 验证配置是否生效

### 步骤3：填充数据直到内存满

- 写入多个key（每个约100KB）
- 监控内存使用情况
- 当内存接近上限时停止

### 步骤4：继续写入新数据，观察淘汰行为

- 尝试写入新数据（触发淘汰）
- 观察哪些key被淘汰
- 记录淘汰结果

### 步骤5：分析淘汰结果

- 统计被淘汰的key数量
- 显示被淘汰的key列表
- 显示内存使用和淘汰统计

## 预期结果

### allkeys-lru（推荐）

**预期行为**：
- 淘汰最久未访问的key
- 保留最近访问的key

**示例输出**：
```
写入新数据前存在的key数量: 50
写入新数据后存在的key数量: 45
被淘汰的key数量: 5

被淘汰的key（前10个）：
  - test:key:0
  - test:key:1
  - test:key:2
  ...
```

### volatile-lru

**预期行为**：
- 只淘汰设置了过期时间的key
- 淘汰最久未访问的key

**注意**：
- 需要先设置过期时间（实验会自动设置）
- 永久key不会被淘汰

### allkeys-lfu

**预期行为**：
- 淘汰访问频率最低的key
- 保留高频访问的key

**特点**：
- 适合访问频率差异大的场景
- 需要统计访问频率

### volatile-lfu

**预期行为**：
- 只淘汰设置了过期时间的key
- 淘汰访问频率最低的key

### allkeys-random

**预期行为**：
- 随机选择key删除
- 不可预测

**注意**：
- 不推荐生产环境使用
- 适合测试场景

### volatile-random

**预期行为**：
- 只淘汰设置了过期时间的key
- 随机选择

### volatile-ttl

**预期行为**：
- 只淘汰设置了过期时间的key
- 优先淘汰TTL最小的key（即将过期）

**示例**：
```
SET user:1 "alice" EX 100  # TTL = 100秒
SET user:2 "bob" EX 3600  # TTL = 3600秒

# 内存满时，优先淘汰 user:1（TTL最小）
```

### noeviction

**预期行为**：
- 不淘汰任何key
- 内存满时，写操作返回错误

**示例输出**：
```
❌ 写入失败 (noeviction策略): key=test:new:key:100, error=OOM command not allowed when used memory > 'maxmemory'
```

## 观察要点

### 1. 淘汰数量

**观察**：
- 写入新数据后，有多少key被淘汰？
- 淘汰数量是否合理？

**分析**：
- LRU/LFU：淘汰数量取决于访问模式
- Random：随机淘汰，数量不确定
- noeviction：不淘汰，返回错误

### 2. 被淘汰的key

**观察**：
- 哪些key被淘汰了？
- 是否符合策略的预期？

**分析**：
- **LRU**：应该淘汰最久未访问的key（如 test:key:0, test:key:1）
- **LFU**：应该淘汰访问频率最低的key
- **TTL**：应该淘汰TTL最小的key
- **Random**：随机淘汰，不可预测

### 3. 内存使用

**观察**：
- 内存使用是否接近上限？
- 淘汰后内存是否释放？

**分析**：
- 内存应该接近但不超过上限
- 淘汰后应该有空间写入新数据

### 4. 淘汰统计

**观察**：
- `evicted_keys` 统计值
- 是否与观察到的淘汰数量一致？

## 对比实验

### 运行所有策略对比

```bash
./run_eviction_test.sh all
```

**对比要点**：

| 策略 | 淘汰对象 | 淘汰方式 | 可预测性 |
|------|----------|----------|----------|
| **allkeys-lru** | 所有key | LRU | ⭐⭐⭐⭐⭐ 高 |
| **volatile-lru** | 设置了过期时间的key | LRU | ⭐⭐⭐⭐ 较高 |
| **allkeys-lfu** | 所有key | LFU | ⭐⭐⭐⭐ 较高 |
| **volatile-lfu** | 设置了过期时间的key | LFU | ⭐⭐⭐⭐ 较高 |
| **volatile-ttl** | 设置了过期时间的key | TTL最小 | ⭐⭐⭐⭐⭐ 高 |
| **allkeys-random** | 所有key | 随机 | ⭐ 低 |
| **volatile-random** | 设置了过期时间的key | 随机 | ⭐ 低 |
| **noeviction** | - | 不淘汰 | - |

## 常见问题

### Q1: 为什么没有触发淘汰？

**可能原因**：
1. 内存未达到上限
2. 写入的数据量不够
3. 内存限制设置太大

**解决方案**：
- 检查 `maxmemory` 配置
- 增加写入的数据量
- 减小内存限制（如改为2MB）

### Q2: volatile策略没有淘汰任何key？

**可能原因**：
- 没有设置过期时间
- 所有key都是永久key

**解决方案**：
- 确保key设置了过期时间
- 实验程序会自动为volatile策略设置过期时间

### Q3: noeviction策略返回错误？

**这是正常的**：
- `noeviction` 策略不会淘汰key
- 内存满时，写操作会返回错误
- 这是预期的行为

### Q4: 如何查看Redis的淘汰统计？

```bash
redis-cli INFO stats | grep evicted_keys
```

## 实验建议

### 1. 逐个测试策略

```bash
# 先测试推荐策略
./run_eviction_test.sh allkeys-lru

# 再测试其他策略
./run_eviction_test.sh volatile-ttl
./run_eviction_test.sh allkeys-lfu
```

### 2. 观察不同策略的差异

- **LRU vs LFU**：观察淘汰的key是否不同
- **allkeys vs volatile**：观察淘汰范围是否不同
- **TTL策略**：观察是否优先淘汰即将过期的key

### 3. 调整内存限制

可以修改代码中的 `maxMemory` 值：
```go
maxMemory := "5mb"  // 改为 "2mb" 或 "10mb"
```

### 4. 监控Redis命令

在另一个终端运行：
```bash
redis-cli MONITOR
```

观察实际执行的Redis命令和淘汰行为。

## 恢复Redis配置

实验会修改Redis的配置，测试完成后可以恢复：

```bash
# 查看当前配置
redis-cli CONFIG GET maxmemory
redis-cli CONFIG GET maxmemory-policy

# 恢复配置（根据你的实际需求）
redis-cli CONFIG SET maxmemory 0  # 0表示不限制（或设置你的实际值）
redis-cli CONFIG SET maxmemory-policy noeviction  # 或你的实际策略
```

## 实验技巧

### 1. 观察LRU vs LFU的区别

```bash
# 先运行LRU策略
./run_eviction_test.sh allkeys-lru
# 记录被淘汰的key

# 再运行LFU策略
./run_eviction_test.sh allkeys-lfu
# 对比被淘汰的key是否不同
```

**预期差异**：
- **LRU**：淘汰最久未访问的key（如 test:key:0, test:key:1）
- **LFU**：淘汰访问频率最低的key（可能不是最久的）

### 2. 观察allkeys vs volatile的区别

```bash
# 运行allkeys策略
./run_eviction_test.sh allkeys-lru

# 运行volatile策略
./run_eviction_test.sh volatile-lru
```

**预期差异**：
- **allkeys**：可能淘汰所有key
- **volatile**：只淘汰设置了过期时间的key

### 3. 观察TTL策略

```bash
./run_eviction_test.sh volatile-ttl
```

**预期行为**：
- 优先淘汰TTL最小的key（即将过期）
- 实验会设置不同的TTL值，便于观察

### 4. 观察noeviction策略

```bash
./run_eviction_test.sh noeviction
```

**预期行为**：
- 内存满时，写操作返回错误
- 不会淘汰任何key

## 总结

这个实验可以帮助你：

1. ✅ **理解内存淘汰机制**：如何触发、如何工作
2. ✅ **对比不同策略**：各策略的差异和特点
3. ✅ **选择合适的策略**：根据场景选择最佳策略
4. ✅ **验证配置**：确保策略配置正确

**推荐策略**：
- **缓存场景**：`allkeys-lru`（推荐）
- **数据不能丢失**：`noeviction` + 持久化
- **访问频率差异大**：`allkeys-lfu`
- **优先淘汰即将过期**：`volatile-ttl`

## 故障排查

### 问题1：没有触发淘汰

**可能原因**：
- 内存限制太大
- 写入的数据量不够

**解决方案**：
- 检查 `maxmemory` 配置
- 增加写入的数据量
- 减小内存限制（代码中修改 `maxMemory := "5mb"` 为更小的值）

### 问题2：volatile策略没有淘汰key

**可能原因**：
- 所有key都没有设置过期时间

**解决方案**：
- 实验程序会自动为volatile策略设置过期时间
- 检查key是否有TTL：`redis-cli TTL test:key:0`

### 问题3：编译错误

**可能原因**：
- 缺少依赖

**解决方案**：
```bash
go mod tidy
go mod download
```
