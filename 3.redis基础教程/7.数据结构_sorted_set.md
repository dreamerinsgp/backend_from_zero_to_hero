录制：redis基础11_有序集合基础用法.mp4
日期：2026-01-30 22:38:23
录制文件：https://meeting.tencent.com/crm/Ngy7GBBz2a


### 2.2 Sorted Set类型 - 有序集合

**学习目标**: 掌握Sorted Set，理解时间序列数据存储

**学习内容**:

- ZADD：添加成员和分数
- ZRANGE/ZREVRANGE：按排名范围查询
- ZRANGEBYSCORE：按分数范围查询（重要！）
- ZREM：删除成员
- ZSCORE：获取成员分数

**项目对应代码**:

- `model/redismodel/kline.go:59` - ZRANGEBYSCORE（K线数据查询）
- 用于存储时间序列的金融数据（K线图）

**实践任务**:

1. 实现排行榜功能（ZREVRANGE）
2. 实现时间范围查询（ZRANGEBYSCORE，参考kline.go）
3. 实现延迟队列（用分数表示执行时间）


Q1: 基础用法

Q2: 底层数据结构 （重点解释是怎么实现有序的）

Redis Sorted Set 的底层使用两种编码方式，根据元素数量和大小自动选择：

1. **LISTPACK（列表包）** - 小有序集合
   - 条件：元素数量 <= 128（zset_max_listpack_entries）且 元素值 <= 64 字节（zset_max_listpack_value）
   - 结构：连续内存，按分数排序存储
   - 特点：内存紧凑，适合小集合

2. **SKIPLIST（跳表）+ HASHTABLE（哈希表）** - 大有序集合
   - 条件：元素数量 > 128 或 元素值 > 64 字节
   - 结构：跳表维护有序性，哈希表提供 O(1) 查找
   - 特点：查找和插入都是 O(log n)，适合大集合

**自动转换**：当 Sorted Set 变大时，自动从 LISTPACK 转换为 SKIPLIST+HASHTABLE

---

### 1. LISTPACK（列表包）结构

LISTPACK 是连续内存结构，元素按分数从小到大排序存储：

**内存布局**：
```
LISTPACK 存储 [("Alice", 100), ("Charlie", 150), ("Bob", 200)]
┌─────────────────────────────────────────────────────────┐
│ lpbytes │ lptail │ lpcount │ entry1 │ entry2 │ entry3 │ lpend │
│ (4字节) │ (4字节)│ (2字节) │ (变长) │ (变长) │ (变长) │ (1字节)│
└─────────────────────────────────────────────────────────┘

每个 entry 存储：member + score（按分数排序）
```

**特点**：
- 有序存储：插入时按分数找到正确位置插入
- 内存连续：所有数据在连续内存中
- 查找方式：二分查找 O(log n)

**如何实现有序**：
- 插入时遍历找到正确的插入位置（按分数比较）
- 保持元素按分数从小到大排序
- 查询时使用二分查找

---

### 2. SKIPLIST（跳表）+ HASHTABLE（哈希表）结构

这是 Sorted Set 的核心实现，**使用两种数据结构配合实现有序**：

#### 2.1 数据结构定义

```c
// 跳表节点
typedef struct zskiplistNode {
    double score;                    // 分数（排序依据）
    struct zskiplistNode *backward;  // 后向指针（用于反向遍历）
    struct zskiplistLevel {
        struct zskiplistNode *forward;  // 前向指针
        unsigned long span;             // 跨度（用于计算排名）
    } level[];                          // 多层指针数组
    // sds ele 嵌入在节点后面（成员值）
} zskiplistNode;

// 跳表结构
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;  // 头节点和尾节点
    unsigned long length;                  // 元素数量
    int level;                              // 当前最大层数（1-32）
    size_t alloc_size;                     // 分配的内存大小
} zskiplist;

// Sorted Set 结构
typedef struct zset {
    dict *dict;      // 哈希表：member -> zskiplistNode*（O(1)查找）
    zskiplist *zsl;  // 跳表：按分数排序（O(log n)插入和查找）
} zset;
```

#### 2.2 为什么需要两种数据结构？

**跳表（zskiplist）**：
- 作用：维护元素的有序性（按分数排序）
- 优势：支持 O(log n) 的插入、删除、范围查询
- 缺点：查找特定 member 需要 O(log n)

**哈希表（dict）**：
- 作用：快速查找 member 对应的节点
- 优势：O(1) 时间复杂度查找 member
- 缺点：不维护顺序

**配合使用**：
- 跳表负责有序性和范围查询
- 哈希表负责快速查找特定 member
- 两者共享节点，节省内存

---

### 3. 跳表如何实现有序？（核心机制）

#### 3.1 跳表的基本结构

跳表是一个**多层有序链表**，每一层都是有序的：

```
Level 3:  header ──────────────────────────────────────> NULL
           (32层)
Level 2:  header ──────────> node3 ────────────────────> NULL
           (2层)
Level 1:  header ──> node1 ──> node3 ──> node5 ───────> NULL
           (3层)
Level 0:  header ──> node1 ──> node2 ──> node3 ──> node4 ──> node5 ──> NULL
           (所有节点)
```

**关键特性**：
- Level 0：包含所有节点，按分数有序排列
- Level 1+：包含部分节点，形成"快速通道"
- 每层都是有序的（按分数从小到大）

#### 3.2 插入操作（如何保持有序）

**举例：插入 ("Bob", 200)**

```
当前跳表：
Level 1: header ──> (Alice, 100) ──> (Charlie, 150) ──> NULL
Level 0: header ──> (Alice, 100) ──> (Charlie, 150) ──> NULL

插入 (Bob, 200)：
```

**步骤1：从高层向低层查找插入位置**
```
Level 1: 从 header 开始
  - header -> (Alice, 100): 200 > 100，继续
  - (Alice, 100) -> (Charlie, 150): 200 > 150，继续
  - (Charlie, 150) -> NULL: 找到位置，记录 update[1] = (Charlie, 150)

Level 0: 从 (Charlie, 150) 开始
  - (Charlie, 150) -> NULL: 找到位置，记录 update[0] = (Charlie, 150)
```

**步骤2：随机生成层数**
```
随机层数 = 2（假设）
创建新节点，有 Level 0 和 Level 1
```

**步骤3：插入节点并更新指针**
```
Level 1: (Charlie, 150) -> (Bob, 200) -> NULL
Level 0: (Charlie, 150) -> (Bob, 200) -> NULL

结果：
Level 1: header ──> (Alice, 100) ──> (Charlie, 150) ──> (Bob, 200) ──> NULL
Level 0: header ──> (Alice, 100) ──> (Charlie, 150) ──> (Bob, 200) ──> NULL
```

**关键点**：
- 插入时按分数找到正确位置
- 保持每层的有序性
- 时间复杂度：O(log n)

#### 3.3 查找操作（如何利用有序性）

**查找分数为 150 的节点**：

```
Level 1: 从 header 开始
  - header -> (Alice, 100): 150 > 100，继续
  - (Alice, 100) -> (Charlie, 150): 150 == 150，找到！

如果没找到，继续在 Level 0 查找
```

**查找范围 [100, 200]**：

```
Level 1: 找到第一个 >= 100 的节点
Level 0: 从该节点开始，遍历到第一个 > 200 的节点
```

**时间复杂度**：O(log n)

#### 3.4 跳表的层数（如何决定）

**随机层数生成**：
```c
static int zslRandomLevel(void) {
    int level = 1;
    // 每次有 25% 的概率增加一层
    while (random() < ZSKIPLIST_P * RAND_MAX)
        level++;
    return (level < ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
```

**特点**：
- 最大层数：32（ZSKIPLIST_MAXLEVEL = 32）
- 概率：每层有 25% 的概率继续增加
- 分布：低层节点多，高层节点少（形成"快速通道"）

**层数分布示例**：
```
Level 0: 100% 节点（所有节点）
Level 1: ~25% 节点
Level 2: ~6.25% 节点
Level 3: ~1.56% 节点
...
```

---

### 4. 完整的内存布局示例

**存储 [("Alice", 100), ("Charlie", 150), ("Bob", 200)]**

```
┌─────────────────────────────────────────────────────────┐
│ zset 结构                                                │
├─────────────────────────────────────────────────────────┤
│ dict: ────────────────────────────────────────────────┐ │
│ zsl:  ──────────────────────────────────────────────┐ │ │
└──────────────────────────────────────────────────────┘ │ │
                                                        │ │
         ┌──────────────────────────────────────────────┘ │
         │                                                │
         ▼                                                │
┌─────────────────────────────────────────┐             │
│ dict (哈希表)                            │             │
│ ht_table[0]: ────────────────────────┐ │             │
│   "Alice" -> zskiplistNode*          │ │             │
│   "Charlie" -> zskiplistNode*        │ │             │
│   "Bob" -> zskiplistNode*             │ │             │
└───────────────────────────────────────┘ │             │
                                          │             │
         ┌──────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ zskiplist (跳表)                        │
├─────────────────────────────────────────┤
│ header: zskiplistNode* ──────────────┐ │
│ tail: zskiplistNode*                  │ │
│ length: 3                             │ │
│ level: 2                               │ │
└────────────────────────────────────────┘ │
                                            │
         ┌───────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Level 1:                                │
│ header ──> (Alice,100) ──> (Bob,200) ──> NULL │
│                                          │
│ Level 0:                                │
│ header ──> (Alice,100) ──> (Charlie,150) ──> (Bob,200) ──> NULL │
└─────────────────────────────────────────┘

节点结构（以 Alice 节点为例）：
┌─────────────────────────────────────────┐
│ zskiplistNode (Alice)                    │
├─────────────────────────────────────────┤
│ score: 100.0                            │
│ backward: NULL (第一个节点)              │
│ level[0]: forward -> (Charlie,150)      │
│ level[1]: forward -> (Bob,200)          │
│ ele: "Alice" (嵌入在节点后面)            │
└─────────────────────────────────────────┘
```

---

### 5. 有序性的保证机制

#### 5.1 插入时保持有序

1. **查找插入位置**：从高层向低层查找，找到第一个分数 >= 新节点分数的位置
2. **插入节点**：在找到的位置插入新节点
3. **更新指针**：更新所有层的 forward 指针

**代码逻辑**（简化）：
```c
// 1. 查找插入位置
for (i = zsl->level-1; i >= 0; i--) {
    while (score > x->level[i].forward->score) {
        x = x->level[i].forward;  // 向右移动
    }
    update[i] = x;  // 记录需要更新的节点
}

// 2. 插入节点
for (i = 0; i < level; i++) {
    node->level[i].forward = update[i]->level[i].forward;
    update[i]->level[i].forward = node;  // 更新指针
}
```

#### 5.2 删除时保持有序

1. **查找节点**：通过哈希表 O(1) 找到节点
2. **更新指针**：更新所有层的 forward 指针，跳过被删除的节点
3. **释放节点**：释放节点内存

#### 5.3 范围查询利用有序性

**ZRANGEBYSCORE leaderboard 100 200**：

1. **查找起始位置**：在跳表中找到第一个分数 >= 100 的节点
2. **顺序遍历**：从起始节点开始，按 Level 0 顺序遍历
3. **停止条件**：遇到第一个分数 > 200 的节点停止

**时间复杂度**：O(log n + m)，n 是总数，m 是结果数量

---

### 6. LISTPACK vs SKIPLIST 对比

| 特性 | LISTPACK | SKIPLIST+HASHTABLE |
|------|----------|-------------------|
| **内存布局** | 连续内存 | 非连续（指针连接） |
| **查找方式** | 二分查找 O(log n) | 跳表 O(log n) + 哈希表 O(1) |
| **插入方式** | 找到位置后移动元素 O(n) | 跳表插入 O(log n) |
| **删除方式** | 移动元素 O(n) | 跳表删除 O(log n) |
| **内存占用** | 小（紧凑存储） | 较大（需要指针和哈希表） |
| **适用场景** | 小集合（≤128个元素） | 大集合 |
| **有序性保证** | 插入时排序 | 跳表天然有序 |

---

### 7. 实际应用场景分析

**场景1：排行榜（适合 SKIPLIST）**
```
ZADD leaderboard 1000 "player1" 1500 "player2" 800 "player3"
// 元素数量可能很大，使用 SKIPLIST
// 支持快速插入、删除、范围查询
```

**场景2：K线数据（适合 SKIPLIST）**
```
ZADD kline:BTC:USDT:1m 1705296000 '{"open":50000,...}'
// 时间序列数据，数量大
// 需要按时间戳范围查询（ZRANGEBYSCORE）
// SKIPLIST 的 O(log n) 范围查询性能好
```

**场景3：小集合（适合 LISTPACK）**
```
ZADD small:set 10 "a" 20 "b" 30 "c"
// 元素数量 ≤ 128，使用 LISTPACK
// 内存占用小，性能足够
```

---

### 8. 配置参数

Redis 配置文件中可以调整：
```conf
zset-max-listpack-entries 128    # LISTPACK 最大元素数
zset-max-listpack-value 64       # LISTPACK 最大元素值（字节）
```

**说明**：
- 当 Sorted Set 元素数量超过 128 或元素值超过 64 字节时，自动转换为 SKIPLIST+HASHTABLE
- 默认值：128 和 64
- 如果集合较小，会使用 LISTPACK 节省内存

---

### 9. 总结：如何实现有序？

**核心机制**：

1. **LISTPACK**：
   - 插入时按分数找到正确位置
   - 保持元素按分数从小到大排序
   - 查询时使用二分查找

2. **SKIPLIST**：
   - 多层有序链表结构
   - 插入时按分数找到正确位置并插入
   - 每层都保持有序性
   - 利用"快速通道"实现 O(log n) 查找

3. **HASHTABLE**：
   - 提供 O(1) 的 member 查找
   - 与跳表共享节点，节省内存

**有序性的保证**：
- 插入时：按分数找到正确位置，保持有序
- 删除时：更新指针，保持有序
- 查询时：利用有序性进行范围查询

**时间复杂度**：
- 插入：O(log n)
- 删除：O(log n)
- 查找 member：O(1)（通过哈希表）
- 范围查询：O(log n + m)（m 是结果数量）