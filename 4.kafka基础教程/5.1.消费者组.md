# Consumer Group（消费者组）

---

## Q1: 什么是 Consumer Group？

**Consumer Group（消费者组）** 是 Kafka 中用于组织和管理多个 Consumer 实例的机制，它实现了**负载均衡**和**容错**功能。

### 核心概念

- **定义**：Consumer Group 是一组 Consumer 实例的集合，它们共同消费一个或多个 Topic
- **标识**：每个 Consumer Group 有一个唯一的 **Group ID**
- **作用**：
  - 实现**负载均衡**：将 Topic 的 Partition 分配给不同的 Consumer 实例
  - 实现**容错**：当某个 Consumer 实例失败时，自动重新分配 Partition
  - 实现**水平扩展**：通过增加 Consumer 实例来提高消费速度

### Consumer Group 的工作原理

```
Topic: sol-trades (3 个 Partition)
Consumer Group: data-flow-default-group-1888 (2 个 Consumer 实例)

分配结果：
┌─────────────────────────────────────┐
│  Consumer Group: data-flow-group     │
│  ┌─────────────┐  ┌─────────────┐  │
│  │ Consumer 1  │  │ Consumer 2  │  │
│  │             │  │             │  │
│  │ Partition 0 │  │ Partition 2 │  │
│  │ Partition 1 │  │             │  │
│  └─────────────┘  └─────────────┘  │
└─────────────────────────────────────┘
```

### 关键特性

1. **一个 Partition 只能被一个 Consumer 消费**
   - 同一个 Consumer Group 中，每个 Partition 只会分配给一个 Consumer 实例
   - 这确保了消息的顺序处理和避免重复消费

2. **多个 Consumer Group 可以独立消费同一个 Topic**
   - 不同的 Consumer Group 可以同时消费同一个 Topic
   - 每个 Consumer Group 维护自己的 Offset（消费进度）

**示例**：
```
Topic: sol-trades (3 个 Partition)

Consumer Group 1: data-flow-default-group-1888
  - Consumer 1 → Partition 0, 1
  - Consumer 2 → Partition 2

Consumer Group 2: data-kline-group-api
  - Consumer 1 → Partition 0, 1, 2  (独立消费，有自己的 Offset)
```

---

## Q2: Consumer Group 如何实现负载均衡和容错？

### 1. 负载均衡（Load Balancing）

**机制**：Kafka 使用 **Rebalance（重平衡）** 机制来分配 Partition 给 Consumer 实例。

#### Rebalance 触发时机

1. **Consumer 加入或离开 Consumer Group**
   - 新的 Consumer 实例启动并加入 Consumer Group
   - Consumer 实例停止或崩溃

2. **Topic 的 Partition 数量变化**
   - Topic 的分区数增加或减少

3. **Consumer Group 订阅的 Topic 变化**
   - Consumer Group 订阅了新的 Topic 或取消订阅

#### Partition 分配策略

Kafka 支持多种分配策略：

1. **Range Assignor（范围分配）**
   - 将连续的 Partition 分配给同一个 Consumer
   - 适用于 Partition 数量较少的情况

2. **RoundRobin Assignor（轮询分配）**
   - 按轮询方式分配 Partition
   - 适用于 Partition 数量较多的情况

3. **Sticky Assignor（粘性分配）**
   - 尽量保持原有的分配关系，减少 Rebalance 时的 Partition 迁移
   - 适用于需要减少 Rebalance 开销的场景

**示例**：
```
Topic: sol-trades (6 个 Partition: 0, 1, 2, 3, 4, 5)
Consumer Group: data-flow-group (3 个 Consumer)

Range Assignor 分配结果：
- Consumer 1 → Partition 0, 1
- Consumer 2 → Partition 2, 3
- Consumer 3 → Partition 4, 5

RoundRobin Assignor 分配结果：
- Consumer 1 → Partition 0, 3
- Consumer 2 → Partition 1, 4
- Consumer 3 → Partition 2, 5
```

#### Rebalance 过程

```
1. Consumer 加入/离开 → 触发 Rebalance
2. 所有 Consumer 停止消费 → 释放当前 Partition
3. 重新分配 Partition → 根据分配策略分配
4. Consumer 重新开始消费 → 从上次提交的 Offset 继续
```

**注意**：Rebalance 期间，Consumer Group 会**暂停消费**，直到 Rebalance 完成。

### 2. 容错（Fault Tolerance）

**机制**：当 Consumer 实例失败时，Kafka 会自动检测并重新分配 Partition。

#### 失败检测

Kafka 通过 **Heartbeat（心跳）** 机制检测 Consumer 是否存活：

1. **Session Timeout（会话超时）**
   - Consumer 定期发送心跳给 Broker
   - 如果 Broker 在 `session.timeout.ms` 时间内没有收到心跳，认为 Consumer 失败

2. **Heartbeat Interval（心跳间隔）**
   - Consumer 每隔 `heartbeat.interval.ms` 发送一次心跳
   - 通常设置为 `session.timeout.ms` 的 1/3

#### 容错流程

```
1. Consumer 2 崩溃（停止发送心跳）
   ↓
2. Broker 检测到 Consumer 2 超时（超过 session.timeout.ms）
   ↓
3. 触发 Rebalance
   ↓
4. 将 Consumer 2 的 Partition 重新分配给其他 Consumer
   ↓
5. 其他 Consumer 从上次提交的 Offset 继续消费
```

**示例**：
```
初始状态：
- Consumer 1 → Partition 0, 1
- Consumer 2 → Partition 2, 3

Consumer 2 崩溃后：
- Consumer 1 → Partition 0, 1, 2, 3  (接管了 Consumer 2 的 Partition)
```

#### Offset 管理

- **Offset 提交**：Consumer 定期提交消费进度（Offset）到 Kafka
- **Offset 恢复**：当 Partition 重新分配时，新的 Consumer 从上次提交的 Offset 继续消费
- **避免消息丢失**：即使 Consumer 崩溃，已提交的 Offset 仍然保存，不会丢失消息

---

## Q3: 项目中 Consumer Group 的配置是什么？

### 项目中的 Consumer Group 配置

项目中多个服务使用不同的 Consumer Group 来消费交易数据：

#### 1. **Dataflow 服务**

**配置文件**：`apps/dataflow/etc/dataflow.yaml`

**Consumer Group 配置**：

```yaml
KqSol:
  Group: data-flow-default-group-1888
  Topic: sol-trades
  Consumers: 1
  Processors: 1

KqBsc:
  Group: data-flow-default-group-10
  Topic: bsc-trades
  Consumers: 1
  Processors: 1

KqEth:
  Group: data-flow-default-group10
  Topic: eth-trades
  Consumers: 1
  Processors: 1

KqBase:
  Group: data-flow-default-group10
  Topic: base-trades
  Consumers: 1
  Processors: 1
```

**功能**：
- 消费交易数据（`sol-trades`, `bsc-trades`, `eth-trades`, `base-trades`）
- 生成 K 线数据
- 保存到 MySQL 数据库
- 推送到 WebSocket 服务器

**实现位置**：`apps/dataflow/internal/mqs/consumers/trade_consumer.go`

---

#### 2. **Market 服务**

**配置文件**：`apps/market/etc/market.yaml`

**Consumer Group 配置**：

```yaml
KqSol:
  Group: data-flow-default-group-1888
  Topic: sol-trades
  Consumers: 1
  Processors: 2

KqEth:
  Group: data-kline-group-api
  Topic: evm-trades-v4
  Consumers: 1
  Processors: 1

KqBase:
  Group: data-kline-group-api
  Topic: base-trades-v4
  Consumers: 1
  Processors: 1
```

**功能**：
- 消费交易数据（`sol-trades`, `evm-trades-v4`, `base-trades-v4`）
- 生成 K 线数据
- 保存到 Redis 缓存

**实现位置**：`apps/market/internal/mqs/consumers/trade_consumer.go`

**注意**：
- `KqSol` 使用 `data-flow-default-group-1888`，与 Dataflow 服务**共享**同一个 Consumer Group
- `KqEth` 和 `KqBase` 使用 `data-kline-group-api`，与 Smart Money 服务**共享**同一个 Consumer Group

---

#### 3. **Smart Money 服务**

**配置文件**：`apps/smart_money/etc/smartmoney.yaml`

**Consumer Group 配置**：

```yaml
Kq:
  Group: data-kline-group-api
  Topic: sol-trades
  Consumers: 1
  Processors: 1
```

**功能**：
- 消费交易数据（`sol-trades`）
- 使用 Bloom Filter 识别智能资金地址
- 记录智能资金交易日志到 MySQL
- 发送通知

**实现位置**：`apps/smart_money/internal/mqs/consumers/smart_money_consumer.go`

---

#### 4. **Consumer 服务**

**配置文件**：`apps/consumer/etc/consumer.yaml`

**Consumer Group 配置**：

```yaml
KqSolTrades:
  Group: data-flow-default-group10
  Topic: sol-trades
  Consumers: 1

KqEthTrades:
  Group: data-flow-default-group
  Topic: eth-trades
  Consumers: 3
```

**功能**：
- 消费交易数据（`sol-trades`, `eth-trades`）
- 主要用于测试和开发环境

**注意**：
- `KqEthTrades` 配置了 `Consumers: 3`，表示启动 3 个 Consumer 实例来实现并发消费

---

### Consumer Group 配置总结

| 服务 | Consumer Group | Topic | 用途 | 是否共享 |
|------|---------------|-------|------|---------|
| **Dataflow** | `data-flow-default-group-1888` | `sol-trades` | K 线生成、存储、WebSocket | ✅ 与 Market 共享 |
| **Market** | `data-flow-default-group-1888` | `sol-trades` | K 线生成、Redis 缓存 | ✅ 与 Dataflow 共享 |
| **Dataflow** | `data-flow-default-group-10` | `bsc-trades` | K 线生成、存储 | ❌ 独立 |
| **Dataflow** | `data-flow-default-group10` | `eth-trades`, `base-trades` | K 线生成、存储 | ❌ 独立 |
| **Market** | `data-kline-group-api` | `evm-trades-v4`, `base-trades-v4` | K 线生成、Redis | ✅ 与 Smart Money 共享 |
| **Smart Money** | `data-kline-group-api` | `sol-trades` | 智能资金追踪 | ✅ 与 Market 共享 |
| **Consumer** | `data-flow-default-group10` | `sol-trades` | 测试/开发 | ❌ 独立 |
| **Consumer** | `data-flow-default-group` | `eth-trades` | 测试/开发 | ❌ 独立 |

---

### Consumer Group 配置说明

#### 1. **Group ID（组 ID）**

```yaml
Group: data-flow-default-group-1888
```

- **作用**：唯一标识 Consumer Group
- **命名规范**：通常使用服务名、环境、版本等信息
- **重要性**：不同的 Group ID 表示不同的 Consumer Group，它们会独立消费同一个 Topic

#### 2. **Consumers（消费者实例数）**

```yaml
Consumers: 1
```

- **作用**：指定 Consumer Group 中 Consumer 实例的数量
- **限制**：Consumer 实例数不能超过 Topic 的 Partition 数量
- **扩展**：增加 Consumer 实例可以提高消费速度（需要增加 Partition 数量）

**示例**：
```
Topic: sol-trades (3 个 Partition)
Consumers: 1  → Consumer 1 消费所有 3 个 Partition
Consumers: 2  → Consumer 1 消费 Partition 0, 1; Consumer 2 消费 Partition 2
Consumers: 3  → 每个 Consumer 消费 1 个 Partition（最优）
Consumers: 4  → 无效，第 4 个 Consumer 会空闲（Partition 数量不足）
```

#### 3. **Processors（处理器数量）**

```yaml
Processors: 1
```

- **作用**：指定每个 Consumer 实例内部的消息处理并发数
- **说明**：Processors 是应用层面的并发，不影响 Partition 分配
- **使用场景**：当单个 Partition 的消息处理速度较慢时，可以增加 Processors 来提高处理速度

**示例**：
```
Consumer 1 分配到 Partition 0
Processors: 1  → 单线程处理 Partition 0 的消息
Processors: 2  → 2 个 goroutine 并发处理 Partition 0 的消息
```

---

### 共享 Consumer Group 的注意事项

#### 1. **同一个 Consumer Group 中的 Consumer 会共享 Partition**

**示例**：
```
Consumer Group: data-flow-default-group-1888
  - Dataflow 服务 (1 个 Consumer 实例)
  - Market 服务 (1 个 Consumer 实例)

Topic: sol-trades (3 个 Partition)

分配结果（可能）：
- Dataflow Consumer → Partition 0, 1
- Market Consumer → Partition 2

或者：
- Dataflow Consumer → Partition 0
- Market Consumer → Partition 1, 2
```

**影响**：
- 如果 Dataflow 和 Market 服务需要消费**所有**消息，它们应该使用**不同的** Consumer Group
- 如果它们只需要消费**部分**消息（负载均衡），可以使用**同一个** Consumer Group

#### 2. **项目中的实际使用**

**场景 1：Dataflow 和 Market 共享 `data-flow-default-group-1888`**
- **原因**：两个服务都需要处理 `sol-trades` 消息，但可以负载均衡
- **结果**：每个服务只消费部分 Partition 的消息

**场景 2：Market 和 Smart Money 共享 `data-kline-group-api`**
- **原因**：两个服务都需要处理交易数据，但业务逻辑不同
- **结果**：每个服务只消费部分 Partition 的消息

---

### Consumer Group 最佳实践

#### 1. **Consumer 实例数 = Partition 数量**

```
Topic: sol-trades (3 个 Partition)
Consumers: 3  ← 最优配置
```

- **原因**：每个 Consumer 实例消费一个 Partition，实现最大并发
- **注意**：如果 Consumer 实例数 > Partition 数量，多余的 Consumer 会空闲

#### 2. **使用不同的 Consumer Group 实现多路消费**

```
Topic: sol-trades

Consumer Group 1: data-flow-group
  → 用于 K 线生成

Consumer Group 2: smart-money-group
  → 用于智能资金追踪

Consumer Group 3: analytics-group
  → 用于数据分析
```

- **原因**：不同的业务逻辑需要独立消费所有消息
- **结果**：每个 Consumer Group 都会消费所有 Partition 的消息

#### 3. **监控 Consumer Group 的 Lag（延迟）**

```bash
# 查看 Consumer Group 的消费进度
kafka-consumer-groups.sh --bootstrap-server localhost:9092 \
  --group data-flow-default-group-1888 \
  --describe
```

- **Lag**：表示 Consumer Group 落后 Producer 的消息数量
- **监控**：如果 Lag 持续增长，说明消费速度跟不上生产速度，需要增加 Consumer 实例或优化处理逻辑

---

## 相关文档

- [Consumer 消费者](./5.Consumer消费者.md)
- [Offset 偏移量](./5.2.offset管理.md)
- [Partition 分区](./3.Partition分区.md)
- [Topic 主题](./2.Topic主题.md)
