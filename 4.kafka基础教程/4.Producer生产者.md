# Producer（生产者）

## Q1: 什么是 Producer？

**Producer（生产者）** 是 Kafka 中负责向 Topic 发送消息的客户端应用程序。

### 核心概念

- **作用**：将消息发送到 Kafka 集群的指定 Topic
- **特点**：
  - 支持同步和异步两种发送方式
  - 自动处理分区选择（根据 Key 或轮询）
  - 支持消息重试和错误处理
  - 支持批量发送以提高性能

### Producer 的工作流程

```
Producer → 序列化消息 → 选择分区 → 发送到 Broker → 等待确认
```

---

## Q2: 项目中 Producer 的实现位置在哪里？

项目中 Producer 的实现主要位于以下位置：

### 1. **Consumer 服务中的 Producer**

**位置**：`apps/consumer/internal/logic/mq/producer.go`

**特点**：
- 使用 **同步 Producer** (`sarama.SyncProducer`)
- 发送消息后等待确认
- 适合需要确保消息发送成功的场景

**关键代码**：
```go
var _kafkaClient sarama.SyncProducer

func NewKafka(conf KqConf) sarama.SyncProducer {
    // 创建同步 Producer
    _kafkaClient, err = newAccessLogProducer(conf.Brokers, ...)
    return _kafkaClient
}

func SendEventLogKafkaInfoMessage(topic string, key string, data []byte) error {
    message := &sarama.ProducerMessage{
        Topic: topic,
        Key:   &accessLogEntry{encoded: []byte(key)},
        Value: &accessLogEntry{encoded: data},
    }
    
    p, o, err := _kafkaClient.SendMessage(message)
    // 返回 partition, offset, error
    return err
}
```

### 2. **Market 服务中的 Producer**

**位置**：`apps/market/internal/mqs/producer/producer.go`

**特点**：
- 使用 **异步 Producer** (`sarama.AsyncProducer`)
- 非阻塞发送，性能更高
- 通过 channel 发送消息

**关键代码**：
```go
var _kfakaClient sarama.AsyncProducer

func NewKfaka(conf KqConf) sarama.AsyncProducer {
    // 创建异步 Producer
    _kfakaClient, err = newAccessLogProducer(conf.Brokers, ...)
    return _kfakaClient
}

func SendMessage(topic string, key string, data []byte) error {
    _kfakaClient.Input() <- &sarama.ProducerMessage{
        Topic: topic,
        Key:   &accessLogEntry{encoded: []byte(key)},
        Value: &accessLogEntry{encoded: data},
    }
    return nil
}
```

### 3. **配置结构**

两个实现都使用相同的配置结构：

```go
type KqConf struct {
    Brokers  []string  // Kafka Broker 地址列表
    Group    string    // Consumer Group（用于 Consumer）
    CaFile   string    // TLS CA 证书文件（可选）
    Username string    // SASL 用户名（可选）
    Password string    // SASL 密码（可选）
}
```

---

## Q3: 如何发送消息到 Kafka？

### 方式 1：使用同步 Producer（推荐用于需要确认的场景）

**适用场景**：
- 需要确保消息发送成功
- 需要知道消息的 partition 和 offset
- 对性能要求不是特别高

**示例代码**：

```go
package main

import (
    "github.com/IBM/sarama"
    "github.com/zeromicro/go-zero/core/logx"
)

// 1. 初始化 Producer
func initProducer() sarama.SyncProducer {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true
    config.Producer.Return.Errors = true
    
    // 使用 Hash 分区器（根据 Key 选择分区）
    config.Producer.Partitioner = sarama.NewHashPartitioner
    
    // 重试配置
    config.Producer.Retry.Max = 3
    config.Producer.Retry.Backoff = 100 * time.Millisecond
    
    // SASL 认证（如果需要）
    config.Net.SASL.Enable = true
    config.Net.SASL.Mechanism = sarama.SASLTypePlaintext
    config.Net.SASL.User = "username"
    config.Net.SASL.Password = "password"
    
    producer, err := sarama.NewSyncProducer(
        []string{"localhost:9092"},
        config,
    )
    if err != nil {
        logx.Errorf("Failed to create producer: %v", err)
        return nil
    }
    
    return producer
}

// 2. 发送消息
func sendMessageSync(producer sarama.SyncProducer) {
    message := &sarama.ProducerMessage{
        Topic: "sol-trades",           // Topic 名称
        Key:   sarama.StringEncoder("trade-123"),  // 消息 Key（用于分区）
        Value: sarama.ByteEncoder([]byte("message content")),  // 消息内容
    }
    
    // 同步发送，等待结果
    partition, offset, err := producer.SendMessage(message)
    if err != nil {
        logx.Errorf("Send failed: %v", err)
        return
    }
    
    logx.Infof("Message sent successfully - Partition: %d, Offset: %d", 
        partition, offset)
}

// 3. 关闭 Producer
func closeProducer(producer sarama.SyncProducer) {
    if err := producer.Close(); err != nil {
        logx.Errorf("Failed to close producer: %v", err)
    }
}
```

### 方式 2：使用异步 Producer（推荐用于高吞吐量场景）

**适用场景**：
- 高吞吐量场景
- 不需要立即知道发送结果
- 可以容忍少量消息丢失

**示例代码**：

```go
package main

import (
    "github.com/IBM/sarama"
    "github.com/zeromicro/go-zero/core/logx"
)

// 1. 初始化异步 Producer
func initAsyncProducer() sarama.AsyncProducer {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true
    config.Producer.Return.Errors = true
    
    // 使用 Hash 分区器
    config.Producer.Partitioner = sarama.NewHashPartitioner
    
    producer, err := sarama.NewAsyncProducer(
        []string{"localhost:9092"},
        config,
    )
    if err != nil {
        logx.Errorf("Failed to create producer: %v", err)
        return nil
    }
    
    // 启动 goroutine 处理成功和错误
    go func() {
        for {
            select {
            case success := <-producer.Successes():
                logx.Infof("Message sent - Topic: %s, Partition: %d, Offset: %d",
                    success.Topic, success.Partition, success.Offset)
            case err := <-producer.Errors():
                logx.Errorf("Message send failed: %v", err)
            }
        }
    }()
    
    return producer
}

// 2. 发送消息（非阻塞）
func sendMessageAsync(producer sarama.AsyncProducer) {
    message := &sarama.ProducerMessage{
        Topic: "sol-trades",
        Key:   sarama.StringEncoder("trade-123"),
        Value: sarama.ByteEncoder([]byte("message content")),
    }
    
    // 异步发送，立即返回
    producer.Input() <- message
}

// 3. 关闭 Producer
func closeAsyncProducer(producer sarama.AsyncProducer) {
    producer.AsyncClose()
}
```

### 方式 3：使用项目中的封装函数

**使用 Consumer 服务中的 Producer**：

```go
import "your-project/apps/consumer/internal/logic/mq"

// 1. 初始化
producer := mq.NewKafka(mq.KqConf{
    Brokers:  []string{"localhost:9092"},
    Username: "username",
    Password: "password",
})

// 2. 发送消息
err := mq.SendEventLogKafkaInfoMessage(
    "sol-trades",           // topic
    "trade-123",            // key
    []byte("message data"), // data
)
```

**使用 Market 服务中的 Producer**：

```go
import "your-project/apps/market/internal/mqs/producer"

// 1. 初始化
kafkaProducer := producer.NewKfaka(producer.KqConf{
    Brokers:  []string{"localhost:9092"},
    Username: "username",
    Password: "password",
})

// 2. 发送消息（异步）
err := producer.SendMessage(
    "sol-trades",
    "trade-123",
    []byte("message data"),
)
```

---

## Producer 配置详解

### 关键配置项

```go
config := sarama.NewConfig()

// 1. 分区器配置
config.Producer.Partitioner = sarama.NewHashPartitioner  // 根据 Key 的 Hash 值选择分区
// 或
config.Producer.Partitioner = sarama.NewRoundRobinPartitioner  // 轮询分区
// 或
config.Producer.Partitioner = sarama.NewRandomPartitioner  // 随机分区

// 2. 确认机制
config.Producer.RequiredAcks = sarama.WaitForAll  // 等待所有副本确认（最安全）
// 或
config.Producer.RequiredAcks = sarama.WaitForLocal  // 只等待 Leader 确认（性能更好）

// 3. 重试配置
config.Producer.Retry.Max = 3  // 最大重试次数
config.Producer.Retry.Backoff = 100 * time.Millisecond  // 重试间隔

// 4. 批量发送配置
config.Producer.Flush.Messages = 100  // 达到 100 条消息时批量发送
config.Producer.Flush.Frequency = 500 * time.Millisecond  // 每 500ms 批量发送一次

// 5. 消息大小限制
config.Producer.MaxMessageBytes = 1024 * 1024 * 10  // 最大消息大小：10MB

// 6. 超时配置
config.Net.DialTimeout = 30 * time.Second
config.Net.ReadTimeout = 30 * time.Second
config.Net.WriteTimeout = 30 * time.Second
```

---

## 分区选择策略

### 1. Hash 分区器（默认，推荐）

```go
config.Producer.Partitioner = sarama.NewHashPartitioner

// 相同 Key 的消息会发送到同一个分区
message1 := &sarama.ProducerMessage{
    Topic: "sol-trades",
    Key:   sarama.StringEncoder("user-123"),  // 相同 Key
    Value: sarama.ByteEncoder([]byte("data1")),
}

message2 := &sarama.ProducerMessage{
    Topic: "sol-trades",
    Key:   sarama.StringEncoder("user-123"),  // 相同 Key
    Value: sarama.ByteEncoder([]byte("data2")),
}
// message1 和 message2 会发送到同一个分区
```

### 2. 轮询分区器

```go
config.Producer.Partitioner = sarama.NewRoundRobinPartitioner

// 消息会依次发送到各个分区（0, 1, 2, 0, 1, 2...）
```

### 3. 随机分区器

```go
config.Producer.Partitioner = sarama.NewRandomPartitioner

// 随机选择分区
```

### 4. 手动指定分区

```go
message := &sarama.ProducerMessage{
    Topic:     "sol-trades",
    Partition: 2,  // 直接指定分区
    Key:       sarama.StringEncoder("key"),
    Value:     sarama.ByteEncoder([]byte("data")),
}
```

---

## 最佳实践

### 1. **选择合适的发送方式**

- **同步发送**：需要确保消息发送成功，可以容忍较低吞吐量
- **异步发送**：高吞吐量场景，可以容忍少量消息丢失

### 2. **合理设置 Key**

```go
// ✅ 好的做法：使用有意义的 Key 确保消息顺序
message := &sarama.ProducerMessage{
    Topic: "sol-trades",
    Key:   sarama.StringEncoder("user-123"),  // 用户 ID，确保同一用户的消息有序
    Value: sarama.ByteEncoder(data),
}

// ❌ 不好的做法：不使用 Key 或使用随机 Key
message := &sarama.ProducerMessage{
    Topic: "sol-trades",
    Key:   nil,  // 没有 Key，无法保证顺序
    Value: sarama.ByteEncoder(data),
}
```

### 3. **错误处理**

```go
// 同步发送的错误处理
partition, offset, err := producer.SendMessage(message)
if err != nil {
    // 记录错误，可能需要重试或告警
    logx.Errorf("Send failed: %v", err)
    // 可以考虑实现重试逻辑或发送到死信队列
    return err
}

// 异步发送的错误处理（在 goroutine 中）
go func() {
    for err := range producer.Errors() {
        logx.Errorf("Async send failed: %v", err)
        // 处理错误
    }
}()
```

### 4. **性能优化**

```go
config := sarama.NewConfig()

// 批量发送
config.Producer.Flush.Messages = 100
config.Producer.Flush.Frequency = 500 * time.Millisecond

// 压缩消息
config.Producer.Compression = sarama.CompressionSnappy

// 异步发送提高吞吐量
producer, _ := sarama.NewAsyncProducer(brokers, config)
```

### 5. **资源管理**

```go
// 确保关闭 Producer
defer func() {
    if err := producer.Close(); err != nil {
        logx.Errorf("Failed to close producer: %v", err)
    }
}()
```

---

## 常见问题

### Q: 如何确保消息发送成功？

**A**: 使用同步 Producer，并检查返回值：

```go
partition, offset, err := producer.SendMessage(message)
if err != nil {
    // 发送失败，需要处理
}
// partition 和 offset 不为 0 表示发送成功
```

### Q: 如何提高发送性能？

**A**: 
1. 使用异步 Producer
2. 启用批量发送
3. 启用消息压缩
4. 使用 `WaitForLocal` 确认机制

### Q: 如何保证消息顺序？

**A**: 
1. 使用相同的 Key（Hash 分区器会确保相同 Key 的消息发送到同一分区）
2. 使用同步发送（异步发送可能乱序）
3. 设置 `max.in.flight.requests.per.connection = 1`

### Q: 消息发送失败怎么办？

**A**: 
1. Producer 会自动重试（根据 `Retry.Max` 配置）
2. 如果重试后仍然失败，需要：
   - 记录错误日志
   - 发送到死信队列
   - 告警通知

---

## 相关文档

- [Topic 主题](./2.Topic主题.md)
- [Partition 分区](./3.Partition分区.md)
- [Consumer 消费者](./5.Consumer消费者.md)
