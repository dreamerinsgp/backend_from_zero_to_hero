# Producer 消息重试和错误处理

---

## Q1：什么是消息重试？

**消息重试**是指当 Producer 发送消息到 Kafka Broker 失败时，自动重新尝试发送消息的机制。

### 核心概念

- **自动重试**：Producer 在遇到可重试的错误时，会自动重新发送消息，无需手动干预
- **重试次数限制**：可以配置最大重试次数，避免无限重试
- **退避策略**：重试之间会有延迟（backoff），避免频繁重试造成系统压力

### 重试机制的工作流程

```
1. Producer 发送消息
   ↓
2. Broker 返回错误（如网络错误、Leader 不可用等）
   ↓
3. Producer 判断是否为可重试错误
   ↓
4. 如果是可重试错误且未达到最大重试次数
   ↓
5. 等待 Backoff 时间
   ↓
6. 重新发送消息
   ↓
7. 重复步骤 2-6，直到成功或达到最大重试次数
```

---

## Q2: 什么场景下需要消息重试？

### ✅ **需要重试的场景**

#### **1. 网络临时故障**

```go
// 场景：网络连接临时中断
// 错误类型：网络超时、连接重置等
// 处理：自动重试，通常能恢复
```

**常见错误**：
- `network timeout`
- `connection reset`
- `no route to host`

#### **2. Broker 临时不可用**

```go
// 场景：Broker 正在重启或负载过高
// 错误类型：Leader 不可用、NotEnoughReplicas 等
// 处理：等待 Leader 选举完成或副本同步后重试
```

**常见错误**：
- `LeaderNotAvailable`
- `NotEnoughReplicas`
- `NotEnoughReplicasAfterAppend`

#### **3. 分区 Leader 切换**

```go
// 场景：Partition Leader 发生变更
// 错误类型：NotLeaderForPartition
// 处理：重新获取元数据，找到新的 Leader 后重试
```

**常见错误**：
- `NotLeaderForPartition`
- `UnknownTopicOrPartition`

#### **4. 消息过大（可配置重试）**

```go
// 场景：消息大小超过限制
// 错误类型：MessageTooLarge
// 处理：通常不应该重试（需要修改消息大小），但可以配置重试
```

**常见错误**：
- `MessageTooLarge`
- `RecordTooLarge`

---

### ❌ **不应该重试的场景**

#### **1. 消息格式错误**

```go
// 场景：消息序列化失败、格式不正确
// 错误类型：序列化错误
// 处理：不应该重试，需要修复代码
```

**常见错误**：
- `SerializationException`
- `InvalidMessageException`

#### **2. 认证/授权失败**

```go
// 场景：SASL 认证失败、权限不足
// 错误类型：认证/授权错误
// 处理：不应该重试，需要检查配置
```

**常见错误**：
- `AuthenticationException`
- `AuthorizationException`

#### **3. Topic 不存在且不允许自动创建**

```go
// 场景：Topic 不存在且 `allow.auto.create.topics=false`
// 错误类型：UnknownTopicOrPartition
// 处理：不应该重试，需要先创建 Topic
```

---

## Q3: 如何实现消息重试？

### 方式 1：使用 Kafka Producer 内置重试机制（推荐）

Kafka Producer 内置了自动重试机制，只需要配置相关参数即可。

#### **配置参数**

```go
config := sarama.NewConfig()

// 1. 最大重试次数
config.Producer.Retry.Max = 3  // 最多重试 3 次

// 2. 重试间隔（退避时间）
config.Producer.Retry.Backoff = 100 * time.Millisecond  // 初始间隔 100ms

// 3. 启用错误返回（用于错误处理）
config.Producer.Return.Errors = true

// 4. 启用成功返回（可选，用于确认）
config.Producer.Return.Successes = true
```

#### **重试策略**

Kafka Producer 使用**指数退避（Exponential Backoff）**策略：

```
第 1 次重试：等待 100ms
第 2 次重试：等待 200ms（或更多，取决于实现）
第 3 次重试：等待 400ms（或更多）
...
```

**退避时间计算**：
- 初始退避：`Retry.Backoff`（如 100ms）
- 指数增长：每次重试时间可能翻倍（取决于实现）
- 最大退避：通常有上限（如 1000ms）

---

### 方式 2：手动实现重试逻辑

如果内置重试机制不满足需求，可以手动实现重试逻辑。

#### **示例：指数退避重试**

```go
package main

import (
    "errors"
    "time"
    "github.com/IBM/sarama"
    "github.com/zeromicro/go-zero/core/logx"
)

// 指数退避重试
func sendWithRetry(producer sarama.SyncProducer, message *sarama.ProducerMessage, maxRetries int) error {
    var lastErr error
    
    for attempt := 0; attempt <= maxRetries; attempt++ {
        if attempt > 0 {
            // 计算退避时间：100ms, 200ms, 400ms...
            backoff := time.Duration(100 * (1 << uint(attempt-1))) * time.Millisecond
            if backoff > 1000*time.Millisecond {
                backoff = 1000 * time.Millisecond  // 最大 1 秒
            }
            
            logx.Infof("Retrying after %v (attempt %d/%d)", backoff, attempt, maxRetries)
            time.Sleep(backoff)
        }
        
        // 尝试发送
        _, _, err := producer.SendMessage(message)
        if err == nil {
            if attempt > 0 {
                logx.Infof("Message sent successfully after %d retries", attempt)
            }
            return nil
        }
        
        lastErr = err
        
        // 判断是否为可重试错误
        if !isRetryableError(err) {
            logx.Errorf("Non-retryable error: %v", err)
            return err
        }
        
        logx.Warnf("Send failed (attempt %d/%d): %v", attempt, maxRetries, err)
    }
    
    return fmt.Errorf("failed after %d retries: %w", maxRetries, lastErr)
}

// 判断是否为可重试错误
func isRetryableError(err error) bool {
    if err == nil {
        return false
    }
    
    // Kafka 可重试错误类型
    kafkaErr, ok := err.(sarama.ProducerError)
    if !ok {
        return false
    }
    
    // 可重试的错误
    retryableErrors := []sarama.KError{
        sarama.ErrLeaderNotAvailable,
        sarama.ErrNotEnoughReplicas,
        sarama.ErrNotEnoughReplicasAfterAppend,
        sarama.ErrNotLeaderForPartition,
        sarama.ErrRequestTimedOut,
        sarama.ErrBrokerNotAvailable,
        sarama.ErrNetworkException,
    }
    
    for _, retryableErr := range retryableErrors {
        if kafkaErr.Err == retryableErr {
            return true
        }
    }
    
    return false
}
```

#### **示例：使用装饰器模式实现重试**

```go
// 重试装饰器
type RetryDecorator struct {
    maxRetries int
    backoff    time.Duration
}

func NewRetryDecorator(maxRetries int, backoff time.Duration) *RetryDecorator {
    return &RetryDecorator{
        maxRetries: maxRetries,
        backoff:    backoff,
    }
}

func (r *RetryDecorator) SendMessage(producer sarama.SyncProducer, message *sarama.ProducerMessage) (int32, int64, error) {
    var lastErr error
    
    for attempt := 0; attempt <= r.maxRetries; attempt++ {
        if attempt > 0 {
            time.Sleep(r.backoff * time.Duration(attempt))  // 线性退避
        }
        
        partition, offset, err := producer.SendMessage(message)
        if err == nil {
            return partition, offset, nil
        }
        
        lastErr = err
        
        if !isRetryableError(err) {
            return -1, -1, err
        }
    }
    
    return -1, -1, fmt.Errorf("failed after %d retries: %w", r.maxRetries, lastErr)
}
```

---

### 方式 3：使用第三方重试库

可以使用第三方库实现更复杂的重试策略，如 `github.com/cenkalti/backoff`。

```go
import (
    "github.com/cenkalti/backoff"
    "github.com/IBM/sarama"
)

func sendWithBackoff(producer sarama.SyncProducer, message *sarama.ProducerMessage) error {
    operation := func() error {
        _, _, err := producer.SendMessage(message)
        return err
    }
    
    // 配置指数退避
    expBackoff := backoff.NewExponentialBackOff()
    expBackoff.InitialInterval = 100 * time.Millisecond
    expBackoff.MaxInterval = 1000 * time.Millisecond
    expBackoff.MaxElapsedTime = 5 * time.Second
    
    // 执行重试
    err := backoff.Retry(operation, expBackoff)
    return err
}
```

---

## Q4: 项目中消息重试的方式？

根据项目代码分析，**项目中使用了 Kafka Producer 内置的重试机制**，两个服务都配置了相同的重试参数。

### 1. Consumer 服务 - 同步 Producer 重试配置

**位置**：`apps/consumer/internal/logic/mq/producer.go`

**重试配置**：

```go
func newAccessLogProducer(brokers []string, _, username, password string) (sarama.SyncProducer, error) {
    config := sarama.NewConfig()
    
    // Retry configurations
    config.Producer.Retry.Max = 3                    // 最大重试 3 次
    config.Producer.Retry.Backoff = 100 * time.Millisecond  // 重试间隔 100ms
    config.Producer.Return.Errors = true            // 返回错误信息
    
    // 其他配置...
    config.Producer.Return.Successes = true         // 返回成功信息
    config.Producer.Timeout = time.Second           // Producer 超时时间 1 秒
    
    producer, err := sarama.NewSyncProducer(brokers, config)
    return producer, err
}
```

**错误处理**：

```go
func SendEventLogKafkaInfoMessage(topic string, key string, data []byte) error {
    message := &sarama.ProducerMessage{
        Topic: topic,
        Key:   &accessLogEntry{encoded: []byte(key)},
        Value: &accessLogEntry{encoded: data},
    }
    
    // 同步发送，内置重试机制会自动重试
    p, o, err := _kafkaClient.SendMessage(message)
    if err != nil {
        // 如果重试 3 次后仍然失败，返回错误
        logx.Errorf("[kafka] send event log to kafka failed: error:%v", err)
        return err
    }
    
    // 发送成功，记录日志
    logx.Infof("[kafka] send event log to kafka success: %v:%v:%v, %v, len(data): %v",
        topic, p, o, key, len(data))
    return nil
}
```

**重试流程**：

```
1. 调用 SendMessage()
   ↓
2. Kafka Producer 内部自动重试（最多 3 次）
   - 第 1 次失败 → 等待 100ms → 重试
   - 第 2 次失败 → 等待更长时间 → 重试
   - 第 3 次失败 → 等待更长时间 → 重试
   ↓
3. 如果 3 次都失败，返回错误
   ↓
4. 调用方检查错误并处理
```

---

### 2. Market 服务 - 异步 Producer 重试配置

**位置**：`apps/market/internal/mqs/producer/producer.go`

**重试配置**：

```go
func newAccessLogProducer(brokers []string, username, password string) (sarama.AsyncProducer, error) {
    config := sarama.NewConfig()
    
    // retry
    config.Producer.Retry.Max = 3                    // 最大重试 3 次
    config.Producer.Retry.Backoff = 100 * time.Millisecond  // 重试间隔 100ms
    config.Producer.Return.Errors = true            // 返回错误信息
    
    // 其他配置...
    config.Producer.RequiredAcks = sarama.WaitForLocal  // 只等待 Leader 确认
    
    producer, err := sarama.NewAsyncProducer(brokers, config)
    
    // 启动 goroutine 处理错误
    go func() {
        for err := range producer.Errors() {
            logx.Errorf("Kafka producer error: %v", err)
        }
    }()
    
    return producer, err
}
```

**错误处理**：

```go
func SendMessage(topic string, key string, data []byte) error {
    if _kfakaClient == nil {
        return errors.New("_kfakaClient is Nil")
    }
    
    // 异步发送，立即返回
    _kfakaClient.Input() <- &sarama.ProducerMessage{
        Topic: topic,
        Key:   &accessLogEntry{encoded: []byte(key)},
        Value: &accessLogEntry{encoded: data},
    }
    
    // 注意：这里返回 nil 不代表消息已发送成功
    // 错误会通过 producer.Errors() channel 异步返回
    return nil
}
```

**重试流程**：

```
1. 调用 Input() <- message（立即返回）
   ↓
2. 消息进入 Producer 内部缓冲区
   ↓
3. Kafka Producer 后台线程自动重试（最多 3 次）
   - 第 1 次失败 → 等待 100ms → 重试
   - 第 2 次失败 → 等待更长时间 → 重试
   - 第 3 次失败 → 等待更长时间 → 重试
   ↓
4. 如果 3 次都失败，错误通过 Errors() channel 返回
   ↓
5. 错误处理 goroutine 记录错误日志
```

---

### 3. 项目中的重试配置总结

| 服务 | Producer 类型 | 最大重试次数 | 重试间隔 | 错误处理方式 |
|------|--------------|------------|---------|------------|
| **Consumer** | 同步 | 3 次 | 100ms | 直接检查返回值 |
| **Market** | 异步 | 3 次 | 100ms | 通过 channel 异步处理 |

**共同特点**：
- ✅ 都使用 Kafka Producer 内置重试机制
- ✅ 都配置了相同的重试参数（Max=3, Backoff=100ms）
- ✅ 都启用了错误返回（`Return.Errors = true`）

**不同点**：
- **Consumer 服务**：同步发送，可以立即知道重试结果
- **Market 服务**：异步发送，错误通过 channel 异步处理

---

## 重试配置的最佳实践

### 1. **合理设置重试次数**

```go
// ✅ 推荐：3-5 次
config.Producer.Retry.Max = 3

// ❌ 不推荐：重试次数过多
config.Producer.Retry.Max = 100  // 可能导致长时间阻塞

// ❌ 不推荐：不重试
config.Producer.Retry.Max = 0    // 任何临时错误都会立即失败
```

**建议**：
- **关键业务**：3-5 次重试
- **非关键业务**：1-3 次重试
- **高吞吐量场景**：1-2 次重试（快速失败）

---

### 2. **合理设置退避时间**

```go
// ✅ 推荐：100-500ms
config.Producer.Retry.Backoff = 100 * time.Millisecond

// ⚠️ 注意：退避时间太短可能导致频繁重试
config.Producer.Retry.Backoff = 10 * time.Millisecond  // 可能太短

// ⚠️ 注意：退避时间太长可能导致延迟过高
config.Producer.Retry.Backoff = 5 * time.Second  // 可能太长
```

**建议**：
- **初始退避**：100-500ms
- **最大退避**：1-5 秒（取决于业务容忍度）

---

### 3. **错误处理策略**

#### **同步发送的错误处理**

```go
func sendMessageSync(producer sarama.SyncProducer, message *sarama.ProducerMessage) error {
    _, _, err := producer.SendMessage(message)
    if err != nil {
        // 1. 记录错误日志
        logx.Errorf("Send failed: %v", err)
        
        // 2. 判断错误类型
        if isRetryableError(err) {
            // 可重试错误：Producer 已经自动重试，这里可以记录或告警
            logx.Warnf("Retryable error occurred: %v", err)
        } else {
            // 不可重试错误：需要人工介入
            logx.Errorf("Non-retryable error: %v", err)
            // 可以考虑发送到死信队列或告警
        }
        
        return err
    }
    
    return nil
}
```

#### **异步发送的错误处理**

```go
func initAsyncProducer() sarama.AsyncProducer {
    producer, _ := sarama.NewAsyncProducer(brokers, config)
    
    // 启动错误处理 goroutine
    go func() {
        for err := range producer.Errors() {
            // 1. 记录错误日志
            logx.Errorf("Async send failed: %v", err)
            
            // 2. 判断错误类型
            if isRetryableError(err.Err) {
                // Producer 已经自动重试，但最终仍然失败
                logx.Errorf("Message failed after retries: %v", err)
                // 可以考虑发送到死信队列
            } else {
                // 不可重试错误
                logx.Errorf("Non-retryable error: %v", err)
            }
            
            // 3. 监控和告警
            // metrics.IncrementErrorCounter()
            // alert.SendAlert(err)
        }
    }()
    
    return producer
}
```

---

### 4. **监控和告警**

```go
// 监控重试次数和失败率
var (
    retryCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "kafka_producer_retries_total",
            Help: "Total number of retries",
        },
        []string{"topic"},
    )
    
    errorCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "kafka_producer_errors_total",
            Help: "Total number of errors",
        },
        []string{"topic", "error_type"},
    )
)

func sendWithMonitoring(producer sarama.SyncProducer, message *sarama.ProducerMessage) error {
    _, _, err := producer.SendMessage(message)
    if err != nil {
        errorCounter.WithLabelValues(message.Topic, err.Error()).Inc()
        
        // 如果错误率过高，发送告警
        if getErrorRate(message.Topic) > 0.1 {
            alert.SendAlert("High Kafka error rate", err)
        }
    }
    
    return err
}
```

---

## 常见错误类型和处理

### 1. **网络错误**

```go
// 错误：network timeout
// 原因：网络连接超时
// 处理：自动重试，通常能恢复
```

### 2. **Broker 错误**

```go
// 错误：LeaderNotAvailable
// 原因：Partition Leader 正在选举
// 处理：自动重试，等待 Leader 选举完成

// 错误：NotEnoughReplicas
// 原因：副本数量不足
// 处理：自动重试，等待副本同步
```

### 3. **消息大小错误**

```go
// 错误：MessageTooLarge
// 原因：消息大小超过限制
// 处理：不应该重试，需要减小消息大小或增加配置
```

### 4. **认证错误**

```go
// 错误：AuthenticationException
// 原因：SASL 认证失败
// 处理：不应该重试，需要检查用户名密码配置
```

---

## 项目中的实际应用

### Consumer 服务的错误处理

```go
// 实际代码：apps/consumer/internal/logic/sol/block/send.go
func (s *BlockService) SendTx(_ context.Context, slot int64, trades []*types.TradeWithPair) {
    // ... 数据处理 ...
    
    err = mq.SendEventLogKafkaInfoMessage(SolTradeTopic, fmt.Sprintf("%v", slot), tradeListJsons)
    if err != nil {
        // 如果重试后仍然失败，记录错误但不中断主流程
        logx.Errorf("SendEventLogKafkaInfoMessage err:%v", err)
        return
    }
    
    // 发送成功，继续后续逻辑
}
```

**特点**：
- ✅ 使用同步发送，可以立即知道结果
- ✅ 错误处理简单直接
- ✅ 失败时记录日志但不中断主流程

---

### Market 服务的错误处理

```go
// 实际代码：apps/market/internal/mqs/producer/producer.go
func newAccessLogProducer(...) (sarama.AsyncProducer, error) {
    // ... 配置 ...
    
    producer, err := sarama.NewAsyncProducer(brokers, config)
    
    // 启动错误处理 goroutine
    go func() {
        for err := range producer.Errors() {
            // 记录所有错误（包括重试后仍然失败的）
            logx.Errorf("Kafka producer error: %v", err)
        }
    }()
    
    return producer, err
}
```

**特点**：
- ✅ 使用异步发送，不阻塞主流程
- ✅ 错误通过 channel 异步处理
- ✅ 所有错误都会被记录

---

## 总结

### 项目中的重试策略

1. **使用 Kafka Producer 内置重试**：简单、可靠、无需额外代码
2. **统一的重试配置**：Max=3, Backoff=100ms
3. **错误处理**：
   - 同步发送：直接检查返回值
   - 异步发送：通过 channel 异步处理

### 最佳实践建议

1. ✅ **合理设置重试次数**：3-5 次适合大多数场景
2. ✅ **合理设置退避时间**：100-500ms 初始退避
3. ✅ **区分可重试和不可重试错误**：不可重试错误不应该重试
4. ✅ **监控和告警**：监控重试次数和失败率
5. ✅ **错误处理**：记录日志、发送告警、考虑死信队列

---

## 相关文档

- [Producer 生产者](./4.Producer生产者.md)
- [两种发送方式](./4.1.两种发送方式.md)
- [批量发送](./4.3.批量发送.md)
