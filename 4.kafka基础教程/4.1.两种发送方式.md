# Producer çš„ä¸¤ç§å‘é€æ–¹å¼

Kafka Producer æ”¯æŒä¸¤ç§å‘é€æ¶ˆæ¯çš„æ–¹å¼ï¼š**åŒæ­¥å‘é€**å’Œ**å¼‚æ­¥å‘é€**ã€‚

---

## Q1: è¿™ä¸¤ç§å‘é€æ–¹å¼çš„åŒºåˆ«ï¼Ÿ

### 1. åŒæ­¥å‘é€ï¼ˆSyncProducerï¼‰

**å®šä¹‰**ï¼šå‘é€æ¶ˆæ¯åï¼Œ**é˜»å¡ç­‰å¾…** Kafka Broker è¿”å›ç¡®è®¤ç»“æœï¼Œç„¶åæ‰ç»§ç»­æ‰§è¡Œåç»­ä»£ç ã€‚

**ç‰¹ç‚¹**ï¼š
- âœ… **é˜»å¡å¼**ï¼šè°ƒç”¨ `SendMessage()` åï¼Œçº¿ç¨‹ä¼šé˜»å¡ç›´åˆ°æ”¶åˆ° Broker çš„å“åº”
- âœ… **ç«‹å³è·å¾—ç»“æœ**ï¼šå¯ä»¥ç›´æ¥è·å– partitionã€offset å’Œé”™è¯¯ä¿¡æ¯
- âœ… **å¯é æ€§é«˜**ï¼šå¯ä»¥ç«‹å³çŸ¥é“æ¶ˆæ¯æ˜¯å¦å‘é€æˆåŠŸ
- âŒ **æ€§èƒ½è¾ƒä½**ï¼šæ¯æ¬¡å‘é€éƒ½éœ€è¦ç­‰å¾…ç½‘ç»œå¾€è¿”ï¼Œååé‡è¾ƒä½
- âŒ **å»¶è¿Ÿè¾ƒé«˜**ï¼šå—ç½‘ç»œå»¶è¿Ÿå½±å“ï¼Œå“åº”æ—¶é—´è¾ƒé•¿

**ä»£ç ç¤ºä¾‹**ï¼š

```go
// ä½¿ç”¨åŒæ­¥ Producer
var _kafkaClient sarama.SyncProducer

func SendMessageSync(topic string, key string, data []byte) error {
    message := &sarama.ProducerMessage{
        Topic: topic,
        Key:   sarama.StringEncoder(key),
        Value: sarama.ByteEncoder(data),
    }
    
    // é˜»å¡ç­‰å¾…ï¼Œç›´åˆ°æ”¶åˆ° Broker å“åº”
    partition, offset, err := _kafkaClient.SendMessage(message)
    
    if err != nil {
        // ç«‹å³çŸ¥é“å‘é€å¤±è´¥
        logx.Errorf("Send failed: %v", err)
        return err
    }
    
    // ç«‹å³çŸ¥é“å‘é€æˆåŠŸï¼Œå¹¶è·å¾— partition å’Œ offset
    logx.Infof("Sent - Partition: %d, Offset: %d", partition, offset)
    return nil
}
```

**æ‰§è¡Œæµç¨‹**ï¼š

```
ä¸»çº¿ç¨‹: SendMessage() â†’ [é˜»å¡ç­‰å¾…] â†’ æ”¶åˆ°å“åº” â†’ ç»§ç»­æ‰§è¡Œ
         â†“
    [ç­‰å¾…ç½‘ç»œå¾€è¿”æ—¶é—´]
         â†“
Broker: æ¥æ”¶æ¶ˆæ¯ â†’ å†™å…¥æ—¥å¿— â†’ è¿”å›ç¡®è®¤
```

---

### 2. å¼‚æ­¥å‘é€ï¼ˆAsyncProducerï¼‰

**å®šä¹‰**ï¼šå‘é€æ¶ˆæ¯åï¼Œ**ç«‹å³è¿”å›**ï¼Œä¸ç­‰å¾… Broker ç¡®è®¤ã€‚é€šè¿‡ channel å’Œå›è°ƒå‡½æ•°å¼‚æ­¥å¤„ç†å‘é€ç»“æœã€‚

**ç‰¹ç‚¹**ï¼š
- âœ… **éé˜»å¡**ï¼šè°ƒç”¨ `Input() <- message` åç«‹å³è¿”å›ï¼Œä¸ç­‰å¾…å“åº”
- âœ… **é«˜æ€§èƒ½**ï¼šå¯ä»¥æ‰¹é‡å‘é€ï¼Œååé‡é«˜
- âœ… **ä½å»¶è¿Ÿ**ï¼šå‘é€æ“ä½œæœ¬èº«å»¶è¿Ÿæä½
- âŒ **ç»“æœå»¶è¿Ÿ**ï¼šéœ€è¦é€šè¿‡ channel å¼‚æ­¥è·å–å‘é€ç»“æœ
- âŒ **é”™è¯¯å¤„ç†å¤æ‚**ï¼šéœ€è¦åœ¨å•ç‹¬çš„ goroutine ä¸­å¤„ç†é”™è¯¯

**ä»£ç ç¤ºä¾‹**ï¼š

```go
// ä½¿ç”¨å¼‚æ­¥ Producer
var _kafkaClient sarama.AsyncProducer

func initAsyncProducer() {
    // åˆ›å»ºå¼‚æ­¥ Producer
    _kafkaClient, _ = sarama.NewAsyncProducer(brokers, config)
    
    // å¯åŠ¨ goroutine å¤„ç†å‘é€ç»“æœ
    go func() {
        for {
            select {
            case success := <-_kafkaClient.Successes():
                // å¼‚æ­¥æ”¶åˆ°æˆåŠŸé€šçŸ¥
                logx.Infof("Sent - Partition: %d, Offset: %d",
                    success.Partition, success.Offset)
            case err := <-_kafkaClient.Errors():
                // å¼‚æ­¥æ”¶åˆ°é”™è¯¯é€šçŸ¥
                logx.Errorf("Send failed: %v", err)
            }
        }
    }()
}

func SendMessageAsync(topic string, key string, data []byte) error {
    message := &sarama.ProducerMessage{
        Topic: topic,
        Key:   sarama.StringEncoder(key),
        Value: sarama.ByteEncoder(data),
    }
    
    // ç«‹å³è¿”å›ï¼Œä¸ç­‰å¾…å“åº”
    _kafkaClient.Input() <- message
    return nil  // è¿™é‡Œè¿”å›ä¸ä»£è¡¨æ¶ˆæ¯å·²å‘é€æˆåŠŸ
}
```

**æ‰§è¡Œæµç¨‹**ï¼š

```
ä¸»çº¿ç¨‹: Input() <- message â†’ [ç«‹å³è¿”å›] â†’ ç»§ç»­æ‰§è¡Œ
         â†“
    æ¶ˆæ¯è¿›å…¥å†…éƒ¨ç¼“å†²åŒº
         â†“
åå°çº¿ç¨‹: æ‰¹é‡å‘é€ â†’ Broker å¤„ç† â†’ é€šè¿‡ channel è¿”å›ç»“æœ
```

---

### 3. æ ¸å¿ƒåŒºåˆ«å¯¹æ¯”

| ç‰¹æ€§ | åŒæ­¥å‘é€ï¼ˆSyncProducerï¼‰ | å¼‚æ­¥å‘é€ï¼ˆAsyncProducerï¼‰ |
|------|------------------------|--------------------------|
| **é˜»å¡æ€§** | é˜»å¡ï¼Œç­‰å¾…å“åº” | éé˜»å¡ï¼Œç«‹å³è¿”å› |
| **è¿”å›å€¼** | ç›´æ¥è¿”å› partitionã€offsetã€error | é€šè¿‡ channel å¼‚æ­¥è¿”å› |
| **æ€§èƒ½** | è¾ƒä½ï¼ˆå—ç½‘ç»œå»¶è¿Ÿå½±å“ï¼‰ | è¾ƒé«˜ï¼ˆå¯æ‰¹é‡å‘é€ï¼‰ |
| **ååé‡** | ä½ | é«˜ |
| **å»¶è¿Ÿ** | é«˜ï¼ˆéœ€è¦ç­‰å¾…ç½‘ç»œå¾€è¿”ï¼‰ | ä½ï¼ˆå‘é€æ“ä½œæœ¬èº«ï¼‰ |
| **å¯é æ€§** | é«˜ï¼ˆç«‹å³çŸ¥é“ç»“æœï¼‰ | ä¸­ï¼ˆéœ€è¦å¼‚æ­¥å¤„ç†é”™è¯¯ï¼‰ |
| **é”™è¯¯å¤„ç†** | ç®€å•ï¼ˆç›´æ¥æ£€æŸ¥è¿”å›å€¼ï¼‰ | å¤æ‚ï¼ˆéœ€è¦ç›‘å¬ channelï¼‰ |
| **é€‚ç”¨åœºæ™¯** | éœ€è¦ç¡®ä¿å‘é€æˆåŠŸ | é«˜ååé‡åœºæ™¯ |

---

## Q2: ä¸¤ç§æ–¹å¼é€‚åˆçš„åœºæ™¯ï¼Ÿ

### åŒæ­¥å‘é€é€‚åˆçš„åœºæ™¯

#### âœ… **1. éœ€è¦ç¡®ä¿æ¶ˆæ¯å‘é€æˆåŠŸçš„åœºæ™¯**

```go
// ç¤ºä¾‹ï¼šè®¢å•æ”¯ä»˜æˆåŠŸåï¼Œå¿…é¡»ç¡®ä¿é€šçŸ¥æ¶ˆæ¯å‘é€æˆåŠŸ
func processPayment(orderID string) error {
    // å¤„ç†æ”¯ä»˜é€»è¾‘
    err := processPaymentLogic(orderID)
    if err != nil {
        return err
    }
    
    // å¿…é¡»ç¡®ä¿é€šçŸ¥æ¶ˆæ¯å‘é€æˆåŠŸ
    partition, offset, err := producer.SendMessage(&sarama.ProducerMessage{
        Topic: "payment-notifications",
        Key:   sarama.StringEncoder(orderID),
        Value: sarama.ByteEncoder(paymentData),
    })
    
    if err != nil {
        // å¦‚æœå‘é€å¤±è´¥ï¼Œéœ€è¦å›æ»šæ”¯ä»˜æ“ä½œ
        rollbackPayment(orderID)
        return err
    }
    
    // è®°å½•å‘é€æˆåŠŸçš„ partition å’Œ offsetï¼Œç”¨äºåç»­è¿½è¸ª
    logPaymentNotification(orderID, partition, offset)
    return nil
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- é‡‘èäº¤æ˜“é€šçŸ¥
- å…³é”®ä¸šåŠ¡äº‹ä»¶è®°å½•
- éœ€è¦äº‹åŠ¡ä¸€è‡´æ€§çš„åœºæ™¯

#### âœ… **2. éœ€è¦ç«‹å³çŸ¥é“å‘é€ç»“æœçš„åœºæ™¯**

```go
// ç¤ºä¾‹ï¼šAPI å“åº”ä¸­éœ€è¦è¿”å›æ¶ˆæ¯çš„ offset
func createTrade(w http.ResponseWriter, r *http.Request) {
    tradeData := parseTradeData(r)
    
    partition, offset, err := producer.SendMessage(&sarama.ProducerMessage{
        Topic: "trades",
        Key:   sarama.StringEncoder(tradeData.ID),
        Value: sarama.ByteEncoder(tradeData),
    })
    
    if err != nil {
        http.Error(w, "Failed to create trade", http.StatusInternalServerError)
        return
    }
    
    // åœ¨ API å“åº”ä¸­è¿”å›æ¶ˆæ¯ä½ç½®
    response := map[string]interface{}{
        "trade_id": tradeData.ID,
        "partition": partition,
        "offset": offset,
    }
    json.NewEncoder(w).Encode(response)
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- REST API éœ€è¦è¿”å›æ¶ˆæ¯ä½ç½®
- éœ€è¦ç«‹å³è¿½è¸ªæ¶ˆæ¯
- è°ƒè¯•å’Œç›‘æ§åœºæ™¯

#### âœ… **3. ä½ååé‡ä½†é«˜å¯é æ€§è¦æ±‚çš„åœºæ™¯**

```go
// ç¤ºä¾‹ï¼šç”¨æˆ·æ“ä½œæ—¥å¿—ï¼ˆé¢‘ç‡ä¸é«˜ï¼Œä½†å¿…é¡»å¯é ï¼‰
func logUserAction(userID string, action string) {
    _, _, err := producer.SendMessage(&sarama.ProducerMessage{
        Topic: "user-actions",
        Key:   sarama.StringEncoder(userID),
        Value: sarama.ByteEncoder(action),
    })
    
    if err != nil {
        // è®°å½•åˆ°æœ¬åœ°æ–‡ä»¶ä½œä¸ºå¤‡ä»½
        logToLocalFile(userID, action, err)
    }
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- æ“ä½œæ—¥å¿—è®°å½•
- å®¡è®¡æ—¥å¿—
- ä½é¢‘ä½†é‡è¦çš„æ¶ˆæ¯

---

### å¼‚æ­¥å‘é€é€‚åˆçš„åœºæ™¯

#### âœ… **1. é«˜ååé‡åœºæ™¯**

```go
// ç¤ºä¾‹ï¼šå¸‚åœºæ•°æ®æµï¼ˆæ¯ç§’æ•°åƒæ¡æ¶ˆæ¯ï¼‰
func streamMarketData(marketDataChan <-chan MarketData) {
    producer := initAsyncProducer()
    
    for data := range marketDataChan {
        // éé˜»å¡å‘é€ï¼Œå¯ä»¥å¿«é€Ÿå¤„ç†å¤§é‡æ¶ˆæ¯
        producer.Input() <- &sarama.ProducerMessage{
            Topic: "market-data",
            Key:   sarama.StringEncoder(data.Symbol),
            Value: sarama.ByteEncoder(data.ToJSON()),
        }
        // ç«‹å³å¤„ç†ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œä¸ç­‰å¾…å‘é€ç»“æœ
    }
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- å®æ—¶æ•°æ®æµï¼ˆå¸‚åœºæ•°æ®ã€æ—¥å¿—æµï¼‰
- é«˜å¹¶å‘åœºæ™¯
- æ‰¹é‡æ•°æ®å¤„ç†

#### âœ… **2. å¯ä»¥å®¹å¿å°‘é‡æ¶ˆæ¯ä¸¢å¤±çš„åœºæ™¯**

```go
// ç¤ºä¾‹ï¼šç»Ÿè®¡æŒ‡æ ‡ä¸ŠæŠ¥ï¼ˆä¸¢å¤±å°‘é‡æ•°æ®ä¸å½±å“æ•´ä½“ï¼‰
func reportMetrics(metrics Metrics) {
    // å¼‚æ­¥å‘é€ï¼Œå³ä½¿å¤±è´¥ä¹Ÿä¸å½±å“ä¸»æµç¨‹
    asyncProducer.Input() <- &sarama.ProducerMessage{
        Topic: "metrics",
        Value: sarama.ByteEncoder(metrics.ToJSON()),
    }
    
    // ç»§ç»­æ‰§è¡Œå…¶ä»–é€»è¾‘ï¼Œä¸ç­‰å¾…å‘é€ç»“æœ
    processOtherLogic()
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- ç»Ÿè®¡æŒ‡æ ‡ä¸ŠæŠ¥
- ç›‘æ§æ•°æ®
- éå…³é”®ä¸šåŠ¡æ•°æ®

#### âœ… **3. éœ€è¦æ‰¹é‡å‘é€çš„åœºæ™¯**

```go
// ç¤ºä¾‹ï¼šæ‰¹é‡å¯¼å…¥æ•°æ®
func batchImportData(items []DataItem) {
    producer := initAsyncProducer()
    
    // é…ç½®æ‰¹é‡å‘é€
    config.Producer.Flush.Messages = 100  // è¾¾åˆ° 100 æ¡æ—¶æ‰¹é‡å‘é€
    config.Producer.Flush.Frequency = 500 * time.Millisecond  // æ¯ 500ms æ‰¹é‡å‘é€
    
    for _, item := range items {
        producer.Input() <- &sarama.ProducerMessage{
            Topic: "import-data",
            Value: sarama.ByteEncoder(item.ToJSON()),
        }
    }
    
    // æ‰€æœ‰æ¶ˆæ¯è¿›å…¥ç¼“å†²åŒºï¼Œç”± Producer æ‰¹é‡å‘é€
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- æ•°æ®å¯¼å…¥
- æ‰¹é‡å¤„ç†
- ETL ä»»åŠ¡

---

## Q3: æˆ‘ä»¬çš„å®é™…é¡¹ç›®ä¸­ï¼Œé‡‡ç”¨çš„ä»€ä¹ˆæ–¹å¼ï¼Ÿ

æ ¹æ®é¡¹ç›®ä»£ç åˆ†æï¼Œ**é¡¹ç›®ä¸­åŒæ—¶ä½¿ç”¨äº†ä¸¤ç§æ–¹å¼**ï¼Œæ ¹æ®ä¸åŒçš„æœåŠ¡éœ€æ±‚é€‰æ‹©ï¼š

### 1. Consumer æœåŠ¡ - ä½¿ç”¨åŒæ­¥å‘é€

**ä½ç½®**ï¼š`apps/consumer/internal/logic/mq/producer.go`

**å®ç°æ–¹å¼**ï¼š`sarama.SyncProducer`

**å…³é”®ä»£ç **ï¼š

```go
var _kafkaClient sarama.SyncProducer

func NewKafka(conf KqConf) sarama.SyncProducer {
    // åˆ›å»ºåŒæ­¥ Producer
    _kafkaClient, err = newAccessLogProducer(conf.Brokers, ...)
    return _kafkaClient
}

func SendEventLogKafkaInfoMessage(topic string, key string, data []byte) error {
    message := &sarama.ProducerMessage{
        Topic: topic,
        Key:   &accessLogEntry{encoded: []byte(key)},
        Value: &accessLogEntry{encoded: data},
    }
    
    // åŒæ­¥å‘é€ï¼Œé˜»å¡ç­‰å¾…ç»“æœ
    p, o, err := _kafkaClient.SendMessage(message)
    if err != nil {
        logx.Errorf("[kafka] send event log to kafka failed: error:%v", err)
        return err
    }
    
    // ç«‹å³è®°å½•å‘é€æˆåŠŸçš„ä¿¡æ¯
    logx.Infof("[kafka] send event log to kafka success: %v:%v:%v, %v, len(data): %v",
        topic, p, o, key, len(data))
    return nil
}
```

**å®é™…å‘é€çš„æ¶ˆæ¯å†…å®¹**ï¼š

#### ğŸ“¤ **åœºæ™¯ 1ï¼šå‘é€äº¤æ˜“æ•°æ®åˆ° `sol-trades` Topic**

**è°ƒç”¨ä½ç½®**ï¼š`apps/consumer/internal/logic/sol/block/send.go::SendTx()`

**å‘é€å†…å®¹**ï¼š
- **Topic**: `sol-trades`ï¼ˆä»é…ç½®è¯»å–ï¼‰
- **Key**: Slot ç¼–å·ï¼ˆå¦‚ `"310870231"`ï¼‰
- **Value**: äº¤æ˜“æ•°æ® JSON æ•°ç»„ï¼ˆ`TradeWithPair` ç»“æ„æ•°ç»„ï¼‰

**TradeWithPair ç»“æ„åŒ…å«**ï¼š
```go
type TradeWithPair struct {
    Slot                         int64   // Solana slot ç¼–å·
    ChainId                      string  // é“¾ ID
    PairAddr                     string  // äº¤æ˜“å¯¹åœ°å€
    TxHash                       string  // äº¤æ˜“å“ˆå¸Œ
    Maker                        string  // äº¤æ˜“å‘èµ·è€…åœ°å€
    Type                         string  // äº¤æ˜“ç±»å‹ï¼šbuy/sell/add_position/remove_position
    BaseTokenAmount              float64 // åŸºç¡€ä»£å¸æ•°é‡
    TokenAmount                  float64 // ä»£å¸æ•°é‡
    TokenPriceUSD                float64 // ä»£å¸ä»·æ ¼ï¼ˆUSDï¼‰
    TotalUSD                     float64 // æ€»ä»·å€¼ï¼ˆUSDï¼‰
    BlockNum                     int64   // åŒºå—é«˜åº¦
    BlockTime                    int64   // åŒºå—æ—¶é—´æˆ³
    SwapName                     string  // äº¤æ˜“å¯¹ç‰ˆæœ¬
    CurrentTokenInPoolAmount     float64 // å½“å‰æ± ä¸­ä»£å¸æ•°é‡
    CurrentBaseTokenInPoolAmount float64 // å½“å‰æ± ä¸­åŸºç¡€ä»£å¸æ•°é‡
    // ... æ›´å¤šå­—æ®µ
}
```

**å®é™…ä»£ç **ï¼š
```go
func (s *BlockService) SendTx(_ context.Context, slot int64, trades []*types.TradeWithPair) {
    // 1. è¿‡æ»¤å’ŒéªŒè¯äº¤æ˜“æ•°æ®
    trades = slice.Filter[*types.TradeWithPair](trades, func(index int, item *types.TradeWithPair) bool {
        if item == nil {
            return false
        }
        if item.Type != types.TradeTypeBuy && item.Type != types.TradeTypeSell {
            return false
        }
        if item.TokenPriceUSD == 0 {
            return false
        }
        item.CreateTime = time.Now()
        return true
    })

    // 2. åºåˆ—åŒ–ä¸º JSON
    SolTradeTopic := s.sc.Config.KqSolTrades.Topic
    tradeListJsons, err := json.Marshal(trades)
    if err != nil {
        logx.Errorf("json.Marshal err:%v", err)
        return
    }
    
    // 3. åŒæ­¥å‘é€åˆ° Kafka
    err = mq.SendEventLogKafkaInfoMessage(
        SolTradeTopic,                    // Topic: "sol-trades"
        fmt.Sprintf("%v", slot),          // Key: slot ç¼–å·
        tradeListJsons,                   // Value: äº¤æ˜“æ•°æ® JSON æ•°ç»„
    )
}
```

**ä¸ºä»€ä¹ˆä½¿ç”¨åŒæ­¥å‘é€ï¼Ÿ**
- âœ… **å…³é”®ä¸šåŠ¡æ•°æ®**ï¼šäº¤æ˜“æ•°æ®æ˜¯æ ¸å¿ƒä¸šåŠ¡æ•°æ®ï¼Œå¿…é¡»ç¡®ä¿å‘é€æˆåŠŸ
- âœ… **éœ€è¦è¿½è¸ª**ï¼šéœ€è¦ç«‹å³çŸ¥é“ partition å’Œ offsetï¼Œä¾¿äºåç»­è¿½è¸ªå’Œè°ƒè¯•
- âœ… **æ•°æ®å®Œæ•´æ€§**ï¼šäº¤æ˜“æ•°æ®ä¸¢å¤±ä¼šå½±å“ä¸šåŠ¡é€»è¾‘

#### ğŸ“¤ **åœºæ™¯ 2ï¼šå‘é€äº¤æ˜“å¯¹ä»·æ ¼å˜åŒ–é€šçŸ¥**

**è°ƒç”¨ä½ç½®**ï¼š`apps/consumer/internal/logic/sol/block/send.go::SendPairPriceChange2Kafka()`

**å‘é€å†…å®¹**ï¼š
- **Topic**: `sol-pair-price-change`
- **Key**: Slot ç¼–å·ï¼ˆå¦‚ `"310870231"`ï¼‰
- **Value**: äº¤æ˜“å¯¹åœ°å€ï¼ˆ`pairAddress` å­—ç¬¦ä¸²çš„å­—èŠ‚æ•°ç»„ï¼‰

**å®é™…ä»£ç **ï¼š
```go
func (s *BlockService) SendPairPriceChange2Kafka(_ context.Context, slot int64, pairAddress string) {
    err := mq.SendEventLogKafkaInfoMessage(
        "sol-pair-price-change",          // Topic
        fmt.Sprintf("%v", slot),           // Key: slot ç¼–å·
        []byte(pairAddress),               // Value: äº¤æ˜“å¯¹åœ°å€
    )
}
```

**ä¸ºä»€ä¹ˆä½¿ç”¨åŒæ­¥å‘é€ï¼Ÿ**
- âœ… **é€šçŸ¥ç±»æ¶ˆæ¯**ï¼šä»·æ ¼å˜åŒ–é€šçŸ¥éœ€è¦å¯é ä¼ é€’
- âœ… **ä½é¢‘ç‡**ï¼šä»·æ ¼å˜åŒ–é¢‘ç‡ä¸é«˜ï¼ŒåŒæ­¥å‘é€æ€§èƒ½å½±å“å°

**é…ç½®ç‰¹ç‚¹**ï¼š

```go
config.Producer.Return.Successes = true  // è¿”å›æˆåŠŸä¿¡æ¯
config.Producer.Return.Errors = true      // è¿”å›é”™è¯¯ä¿¡æ¯
config.Producer.Retry.Max = 3             // æœ€å¤§é‡è¯• 3 æ¬¡
config.Producer.Timeout = time.Second      // è¶…æ—¶æ—¶é—´ 1 ç§’
config.Producer.Partitioner = sarama.NewHashPartitioner  // Hash åˆ†åŒºå™¨
```

---

### 2. Market æœåŠ¡ - ä½¿ç”¨å¼‚æ­¥å‘é€

**ä½ç½®**ï¼š`apps/market/internal/mqs/producer/producer.go`

**å®ç°æ–¹å¼**ï¼š`sarama.AsyncProducer`

**å…³é”®ä»£ç **ï¼š

```go
var _kfakaClient sarama.AsyncProducer

func NewKfaka(conf KqConf) sarama.AsyncProducer {
    // åˆ›å»ºå¼‚æ­¥ Producer
    _kfakaClient, err = newAccessLogProducer(conf.Brokers, ...)
    
    // å¯åŠ¨ goroutine å¤„ç†é”™è¯¯
    go func() {
        for err := range producer.Errors() {
            logx.Errorf("Kafka producer error: %v", err)
        }
    }()
    
    return _kfakaClient
}

func SendMessage(topic string, key string, data []byte) error {
    if _kfakaClient == nil {
        return errors.New("_kfakaClient is Nil")
    }
    
    // å¼‚æ­¥å‘é€ï¼Œç«‹å³è¿”å›
    _kfakaClient.Input() <- &sarama.ProducerMessage{
        Topic: topic,
        Key:   &accessLogEntry{encoded: []byte(key)},
        Value: &accessLogEntry{encoded: data},
    }
    return nil  // ç«‹å³è¿”å›ï¼Œä¸ç­‰å¾…å‘é€ç»“æœ
}
```

**å®é™…å‘é€çš„æ¶ˆæ¯å†…å®¹**ï¼š

#### ğŸ“¤ **åœºæ™¯ï¼šå‘é€ K çº¿æ•°æ®åˆ° `klines-{chainId}-{env}` Topic**

**è°ƒç”¨ä½ç½®**ï¼š`apps/market/internal/mqs/producer/sendkline.go::SendKlinesToKafka()`

**å‘é€å†…å®¹**ï¼š
- **Topic**: `klines-{chainId}-{env}`ï¼ˆå¦‚ `klines-1-prod`ï¼‰
- **Key**: äº¤æ˜“å¯¹åœ°å€ï¼ˆ`pairAddress`ï¼‰
- **Value**: Protobuf åºåˆ—åŒ–çš„ K çº¿æ•°æ®ï¼ˆ`Klines` ç»“æ„ï¼‰

**Klines ç»“æ„åŒ…å«**ï¼š
```protobuf
message Kline {
  int64 chain_id = 1;           // é“¾ ID
  string interval = 2;           // æ—¶é—´é—´éš”ï¼ˆå¦‚ "1m", "5m", "1h"ï¼‰
  string pair_addr = 3;          // äº¤æ˜“å¯¹åœ°å€
  double open = 4;               // å¼€ç›˜ä»·
  double high = 5;               // æœ€é«˜ä»·
  double low = 6;               // æœ€ä½ä»·
  double close = 7;              // æ”¶ç›˜ä»·
  double mcap_open = 8;          // å¼€ç›˜å¸‚å€¼
  double mcap_high = 9;          // æœ€é«˜å¸‚å€¼
  double mcap_low = 10;          // æœ€ä½å¸‚å€¼
  double mcap_close = 11;        // æ”¶ç›˜å¸‚å€¼
  double amount_usd = 12;        // äº¤æ˜“é‡‘é¢ï¼ˆUSDï¼‰
  double volume_token = 13;      // äº¤æ˜“é‡ï¼ˆä»£å¸ï¼‰
  int64 candle_time = 14;        // K çº¿æ—¶é—´
  int64 buy_count = 15;          // ä¹°å…¥æ¬¡æ•°
  int64 sell_count = 16;         // å–å‡ºæ¬¡æ•°
  int64 total_count = 17;        // æ€»äº¤æ˜“æ¬¡æ•°
  int64 close_at = 18;           // æ”¶ç›˜æ—¶é—´
  int64 open_at = 19;            // å¼€ç›˜æ—¶é—´
  double avg_price = 20;         // å¹³å‡ä»·æ ¼
  double mkt_cap = 21;           // å¸‚å€¼
  double pump_point = 22;        // Pump åˆ†æ•°
  string token_addr = 23;        // ä»£å¸åœ°å€
}

message Klines {
  repeated Kline list = 1;                    // K çº¿åˆ—è¡¨
  KlineFluctuation fluctuation = 7;           // æ³¢åŠ¨ç‡ä¿¡æ¯
}
```

**å®é™…ä»£ç **ï¼š
```go
func SendKlinesToKafka(config config.Config, chainId int64, pairAddress string, klines *datakline.Klines) {
    // 1. æœ¬åœ°ç¯å¢ƒè·³è¿‡å‘é€
    if config.App.Env == "local" || len(klines.List) == 0 {
        return
    }

    // 2. æ„å»º Topic åç§°
    topic := fmt.Sprintf("klines-%v-%v", chainId, config.App.Env)
    // ä¾‹å¦‚ï¼šklines-1-prod, klines-1-test

    // 3. Protobuf åºåˆ—åŒ–
    bytes, err := proto.Marshal(klines)
    if err != nil {
        logx.Errorf("proto.Marshal err:%v", err)
        return
    }

    // 4. å¼‚æ­¥å‘é€åˆ° Kafka
    err = SendMessage(topic, pairAddress, bytes)
    if err != nil {
        logx.Errorf("SendMessage err:%v", err)
    }
}
```

**ä¸ºä»€ä¹ˆä½¿ç”¨å¼‚æ­¥å‘é€ï¼Ÿ**

1. **é«˜ååé‡éœ€æ±‚**ï¼š
   - K çº¿æ•°æ®æ›´æ–°é¢‘ç‡é«˜ï¼ˆæ¯ä¸ªäº¤æ˜“å¯¹å¯èƒ½æœ‰å¤šä¸ªæ—¶é—´é—´éš”ï¼š1m, 5m, 15m, 1h, 4h, 24hï¼‰
   - å¤šä¸ªäº¤æ˜“å¯¹åŒæ—¶æ›´æ–°ï¼Œéœ€è¦é«˜ååé‡

2. **æ€§èƒ½ä¼˜å…ˆ**ï¼š
   - å¼‚æ­¥å‘é€å¯ä»¥æ‰¹é‡å¤„ç†ï¼Œæé«˜æ€§èƒ½
   - ä½¿ç”¨ Protobuf åºåˆ—åŒ–ï¼Œæ•°æ®ä½“ç§¯å°ï¼Œä¼ è¾“æ•ˆç‡é«˜

3. **å¯å®¹å¿å°‘é‡ä¸¢å¤±**ï¼š
   - K çº¿æ•°æ®å¯ä»¥é‡æ–°è®¡ç®—
   - ä¸¢å¤±å°‘é‡æ•°æ®ä¸å½±å“æ•´ä½“ä¸šåŠ¡

4. **éå…³é”®è·¯å¾„**ï¼š
   - K çº¿æ•°æ®ä¸»è¦ç”¨äºå±•ç¤ºå’Œåˆ†æ
   - ä¸æ˜¯æ ¸å¿ƒä¸šåŠ¡æµç¨‹çš„å…³é”®æ•°æ®

**é…ç½®ç‰¹ç‚¹**ï¼š

```go
config.Producer.RequiredAcks = sarama.WaitForLocal  // åªç­‰å¾… Leader ç¡®è®¤ï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
config.Producer.Return.Errors = true                // è¿”å›é”™è¯¯ï¼ˆé€šè¿‡ channelï¼‰
// config.Producer.Return.Successes = true          // æ³¨é‡Šæ‰ï¼Œä¸éœ€è¦æˆåŠŸé€šçŸ¥
config.Producer.Retry.Max = 3                       // æœ€å¤§é‡è¯• 3 æ¬¡
config.Producer.Partitioner = sarama.NewHashPartitioner  // Hash åˆ†åŒºå™¨
```

---

### 3. é¡¹ç›®ä¸­çš„é€‰æ‹©æ€»ç»“

| æœåŠ¡ | å‘é€æ–¹å¼ | åŸå›  |
|------|---------|------|
| **Consumer æœåŠ¡** | åŒæ­¥å‘é€ | éœ€è¦ç¡®ä¿æ¶ˆæ¯å‘é€æˆåŠŸï¼Œä¾¿äºè¿½è¸ªå’Œè°ƒè¯• |
| **Market æœåŠ¡** | å¼‚æ­¥å‘é€ | é«˜ååé‡éœ€æ±‚ï¼Œæ€§èƒ½ä¼˜å…ˆ |

---

## å¦‚ä½•é€‰æ‹©ï¼Ÿ

### é€‰æ‹©åŒæ­¥å‘é€ï¼Œå¦‚æœï¼š

- âœ… éœ€è¦ç¡®ä¿æ¶ˆæ¯å‘é€æˆåŠŸ
- âœ… éœ€è¦ç«‹å³çŸ¥é“å‘é€ç»“æœï¼ˆpartitionã€offsetï¼‰
- âœ… ååé‡è¦æ±‚ä¸é«˜ï¼ˆ< 1000 msg/sï¼‰
- âœ… é”™è¯¯å¤„ç†éœ€è¦ç®€å•ç›´æ¥
- âœ… ä¸šåŠ¡é€»è¾‘ä¾èµ–æ¶ˆæ¯å‘é€æˆåŠŸ

### é€‰æ‹©å¼‚æ­¥å‘é€ï¼Œå¦‚æœï¼š

- âœ… é«˜ååé‡éœ€æ±‚ï¼ˆ> 1000 msg/sï¼‰
- âœ… å¯ä»¥å®¹å¿å°‘é‡æ¶ˆæ¯ä¸¢å¤±
- âœ… æ€§èƒ½ä¼˜å…ˆ
- âœ… æ‰¹é‡å¤„ç†åœºæ™¯
- âœ… éå…³é”®ä¸šåŠ¡è·¯å¾„

---

## æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹

### åŒæ­¥å‘é€æ€§èƒ½

```go
// æµ‹è¯•ï¼šå‘é€ 1000 æ¡æ¶ˆæ¯
start := time.Now()
for i := 0; i < 1000; i++ {
    _, _, err := syncProducer.SendMessage(&sarama.ProducerMessage{
        Topic: "test",
        Value: sarama.ByteEncoder([]byte("message")),
    })
    if err != nil {
        logx.Errorf("Error: %v", err)
    }
}
duration := time.Since(start)
// ç»“æœï¼šçº¦ 5-10 ç§’ï¼ˆå–å†³äºç½‘ç»œå»¶è¿Ÿï¼‰
// ååé‡ï¼šçº¦ 100-200 msg/s
```

### å¼‚æ­¥å‘é€æ€§èƒ½

```go
// æµ‹è¯•ï¼šå‘é€ 1000 æ¡æ¶ˆæ¯
start := time.Now()
for i := 0; i < 1000; i++ {
    asyncProducer.Input() <- &sarama.ProducerMessage{
        Topic: "test",
        Value: sarama.ByteEncoder([]byte("message")),
    }
}
duration := time.Since(start)
// ç»“æœï¼šçº¦ 10-50 æ¯«ç§’
// ååé‡ï¼šçº¦ 20000-100000 msg/sï¼ˆå–å†³äºæ‰¹é‡é…ç½®ï¼‰
```

---

## æœ€ä½³å®è·µå»ºè®®

### 1. **æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©**

```go
// å…³é”®ä¸šåŠ¡ï¼šä½¿ç”¨åŒæ­¥å‘é€
func processCriticalBusiness(data CriticalData) error {
    _, _, err := syncProducer.SendMessage(&sarama.ProducerMessage{
        Topic: "critical-events",
        Value: sarama.ByteEncoder(data.ToJSON()),
    })
    return err  // å¿…é¡»ç¡®ä¿å‘é€æˆåŠŸ
}

// éå…³é”®ä¸šåŠ¡ï¼šä½¿ç”¨å¼‚æ­¥å‘é€
func processNonCriticalData(data NonCriticalData) {
    asyncProducer.Input() <- &sarama.ProducerMessage{
        Topic: "non-critical-events",
        Value: sarama.ByteEncoder(data.ToJSON()),
    }
    // ä¸ç­‰å¾…ç»“æœï¼Œç»§ç»­å¤„ç†
}
```

### 2. **æ··åˆä½¿ç”¨**

```go
// å¯ä»¥åœ¨åŒä¸€ä¸ªæœåŠ¡ä¸­åŒæ—¶ä½¿ç”¨ä¸¤ç§æ–¹å¼
var syncProducer sarama.SyncProducer   // ç”¨äºå…³é”®æ¶ˆæ¯
var asyncProducer sarama.AsyncProducer // ç”¨äºéå…³é”®æ¶ˆæ¯

func sendMessage(topic string, data []byte, isCritical bool) error {
    if isCritical {
        // å…³é”®æ¶ˆæ¯ï¼šåŒæ­¥å‘é€
        _, _, err := syncProducer.SendMessage(&sarama.ProducerMessage{
            Topic: topic,
            Value: sarama.ByteEncoder(data),
        })
        return err
    } else {
        // éå…³é”®æ¶ˆæ¯ï¼šå¼‚æ­¥å‘é€
        asyncProducer.Input() <- &sarama.ProducerMessage{
            Topic: topic,
            Value: sarama.ByteEncoder(data),
        }
        return nil
    }
}
```

### 3. **é”™è¯¯å¤„ç†**

```go
// åŒæ­¥å‘é€ï¼šç›´æ¥å¤„ç†é”™è¯¯
_, _, err := syncProducer.SendMessage(message)
if err != nil {
    // ç«‹å³å¤„ç†é”™è¯¯
    handleError(err)
    return err
}

// å¼‚æ­¥å‘é€ï¼šé€šè¿‡ channel å¤„ç†é”™è¯¯
go func() {
    for err := range asyncProducer.Errors() {
        // å¼‚æ­¥å¤„ç†é”™è¯¯
        handleError(err.Err)
    }
}()
```

---

## ç›¸å…³æ–‡æ¡£

- [Producer ç”Ÿäº§è€…](./4.Producerç”Ÿäº§è€….md)
- [æ¶ˆæ¯é‡è¯•å’Œé”™è¯¯å¤„ç†](./4.2.æ¶ˆæ¯é‡è¯•å’Œé”™è¯¯å¤„ç†.md)
- [æ‰¹é‡å‘é€](./4.3.æ‰¹é‡å‘é€.md)
