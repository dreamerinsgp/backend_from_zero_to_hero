# Topic（主题）

## Q0: Broker、Partition 和 Topic 的关系？数据流如何串联？

### 核心概念定义

#### **Topic（主题）** - 逻辑容器
- **定义**：消息的逻辑分类，类似于数据库中的表
- **作用**：将消息按业务类型分组（如 `sol-trades`、`eth-trades`）
- **特点**：Topic 本身不存储数据，只是一个逻辑概念

#### **Partition（分区）** - 物理存储单元
- **定义**：Topic 的物理分割，每个 Partition 是一个有序的消息队列
- **作用**：
  - 实现并行处理（多个 Partition 可以并行读写）
  - 保证消息顺序（同一 Partition 内的消息有序）
- **特点**：消息实际存储在 Partition 中

#### **Broker（代理）** - 物理服务器
- **定义**：Kafka 集群中的一台服务器节点
- **作用**：
  - 存储 Partition 的副本（Leader 或 Follower）
  - 处理 Producer 和 Consumer 的请求
- **特点**：多个 Broker 组成 Kafka 集群，提供高可用性

---

### 关系图

```
┌─────────────────────────────────────────────────────────────┐
│                    Kafka 集群（3个 Broker）                    │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │
│  │   Broker 1   │    │   Broker 2   │    │   Broker 3   │  │
│  │              │    │              │    │              │  │
│  │ Topic: sol-  │    │ Topic: sol-  │    │ Topic: sol-  │  │
│  │ trades       │    │ trades       │    │ trades       │  │
│  │              │    │              │    │              │  │
│  │ Partition 0  │    │ Partition 1  │    │ Partition 2  │  │
│  │ (Leader)     │    │ (Leader)     │    │ (Leader)     │  │
│  │              │    │              │    │              │  │
│  │ Partition 1  │    │ Partition 0  │    │ Partition 1  │  │
│  │ (Follower)   │    │ (Follower)   │    │ (Follower)   │  │
│  │              │    │              │    │              │  │
│  │ Partition 2  │    │ Partition 2  │    │ Partition 0  │  │
│  │ (Follower)   │    │ (Follower)   │    │ (Follower)   │  │
│  └──────────────┘    └──────────────┘    └──────────────┘  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**关系总结**：
- **1 个 Topic** = **多个 Partition**（如 `sol-trades` 有 3 个 Partition）
- **1 个 Partition** = **多个副本**（Leader + Follower，分布在不同的 Broker）
- **1 个 Broker** = **存储多个 Partition**（来自不同的 Topic）

---

### 数据流：从 Producer 到 Consumer

让我们通过一个完整的消息发送和消费流程，理解这三个概念如何协同工作：

#### **步骤 1：Producer 发送消息到 Topic**

```go
// Producer 代码示例
message := &sarama.ProducerMessage{
    Topic: "sol-trades",                    // ← 指定 Topic
    Key:   sarama.StringEncoder("slot-123"), // ← 用于路由到 Partition
    Value: sarama.ByteEncoder(tradeData),
}

producer.SendMessage(message)
```

**发生了什么**：
1. Producer 连接到 **Bootstrap Server**（如 `localhost:9092`）
2. 获取集群元数据，找到 `sol-trades` Topic 的所有 Partition
3. 根据 Key 的 Hash 值选择 Partition：
   ```
   partition = hash("slot-123") % 3 = 1  → Partition 1
   ```

---

#### **步骤 2：消息路由到 Partition**

```
Topic: sol-trades
  ├── Partition 0  (存储 slot-100, slot-103, ...)
  ├── Partition 1  (存储 slot-123, slot-126, ...) ← 消息发送到这里
  └── Partition 2  (存储 slot-101, slot-104, ...)
```

**为什么需要 Partition**：
- ✅ **并行处理**：3 个 Partition 可以同时处理 3 条消息
- ✅ **顺序保证**：同一 Key 的消息总是路由到同一 Partition，保证顺序
- ✅ **扩展性**：可以增加 Partition 数量来提高吞吐量

---

#### **步骤 3：找到 Partition 的 Leader Broker**

```
Partition 1 的副本分布：
  Leader:   Broker2  ← 处理读写请求
  Follower: Broker3  ← 同步数据，提供备份
```

**Leader 的作用**：
- 只有 **Leader Broker** 处理 Producer 的写入请求
- 只有 **Leader Broker** 处理 Consumer 的读取请求
- Follower 只是被动同步数据

---

#### **步骤 4：写入 Leader Broker 的磁盘**

```
Broker2 文件系统:
/var/kafka-logs/
  └── sol-trades-1/              ← Partition 1 的目录
      ├── 00000000000000000000.log  ← 消息追加到这里
      ├── 00000000000000000000.index
      └── 00000000000000000000.timeindex
```

**存储结构**：
- 每个 Partition 在 Broker 上有**独立的目录**
- 消息以**追加写入（Append-Only）**方式存储到 `.log` 文件
- 每个消息有唯一的 **Offset**（偏移量）

---

#### **步骤 5：同步到 Follower 副本**

```
Broker2 (Leader)  写入消息到磁盘
    ↓ 同步（异步复制）
Broker3 (Follower) 复制消息到磁盘
```

**副本的作用**：
- **高可用性**：如果 Leader 宕机，Follower 可以提升为新的 Leader
- **数据冗余**：多个副本保证数据不丢失

---

#### **步骤 6：Consumer 从 Partition 读取消息**

```go
// Consumer 代码示例
reader := kafka.NewReader(kafka.ReaderConfig{
    Brokers:  []string{"localhost:9092"},
    Topic:    "sol-trades",           // ← 指定 Topic
    GroupID:  "data-flow-group",      // ← Consumer Group
    MinBytes: 10e3,
    MaxBytes: 10e6,
})

message, _ := reader.ReadMessage(context.Background())
// message.Partition = 1  ← 从 Partition 1 读取
// message.Offset = 123   ← 消息的偏移量
```

**Consumer 读取流程**：
1. Consumer 连接到 Bootstrap Server
2. 获取 Topic 的元数据，找到所有 Partition
3. Consumer Group 协调分配 Partition：
   ```
   Consumer1 → Partition 0
   Consumer2 → Partition 1  ← 读取消息
   Consumer3 → Partition 2
   ```
4. 从 Partition 1 的 **Leader Broker（Broker2）** 读取消息
5. 记录消费进度（Offset），下次从该位置继续读取

---

### 完整数据流图

```
┌─────────────┐
│  Producer   │
│             │
│ 发送消息到    │
│ sol-trades  │
└──────┬──────┘
       │
       │ 1. 根据 Key 路由
       ↓
┌─────────────────────────────────────────────────────────────┐
│                    Topic: sol-trades                        │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │
│  │Partition │    │Partition │    │Partition │             │
│  │    0     │    │    1     │    │    2     │             │
│  └────┬─────┘    └────┬─────┘    └────┬─────┘             │
│       │               │               │                    │
│       │ 2. 找到 Leader Broker                             │
│       ↓               ↓               ↓                    │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐               │
│  │Broker 1 │    │Broker 2 │    │Broker 3 │               │
│  │(Leader) │    │(Leader) │    │(Leader) │               │
│  └─────────┘    └─────────┘    └─────────┘               │
│       │               │               │                    │
│       │ 3. 写入磁盘    │               │                    │
│       ↓               ↓               ↓                    │
│  /var/kafka-logs/    /var/kafka-logs/  /var/kafka-logs/   │
│  sol-trades-0/       sol-trades-1/      sol-trades-2/      │
│       │               │               │                    │
│       │ 4. 同步副本    │               │                    │
│       ↓               ↓               ↓                    │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐               │
│  │Broker 2 │    │Broker 3 │    │Broker 1 │               │
│  │(Follower)│   │(Follower)│   │(Follower)│               │
│  └─────────┘    └─────────┘    └─────────┘               │
└─────────────────────────────────────────────────────────────┘
       │               │               │
       │ 5. Consumer 读取
       ↓               ↓               ↓
┌─────────────┐
│  Consumer   │
│             │
│ 从 Partition│
│ 读取消息     │
└─────────────┘
```

---

### 关键关系总结

| 概念 | 关系 | 说明 |
|------|------|------|
| **Topic → Partition** | 1:N | 1 个 Topic 包含多个 Partition，实现并行处理 |
| **Partition → Broker** | 1:N | 1 个 Partition 有多个副本（Leader + Follower），分布在不同的 Broker |
| **Broker → Partition** | 1:N | 1 个 Broker 存储多个 Partition（来自不同 Topic） |
| **数据流** | Producer → Topic → Partition → Broker → Consumer | 消息从 Producer 发送到 Topic，路由到 Partition，存储在 Broker，被 Consumer 消费 |

---

### 实际例子：项目中的 sol-trades Topic

```yaml
# 项目配置
Topic: sol-trades
Partitions: 3
Replication Factor: 2

# 分布情况
Partition 0:
  Leader:   Broker1
  Follower: Broker2

Partition 1:
  Leader:   Broker2
  Follower: Broker3

Partition 2:
  Leader:   Broker3
  Follower: Broker1
```

**数据流示例**：
1. **Producer** 发送交易数据到 `sol-trades` Topic
2. 根据交易 slot 的 Hash 值，消息路由到 **Partition 1**
3. 消息写入 **Broker2**（Partition 1 的 Leader）的磁盘
4. **Broker3**（Follower）同步数据
5. **Consumer** 从 Broker2 读取 Partition 1 的消息
6. Consumer 处理消息，生成 K 线数据

---
