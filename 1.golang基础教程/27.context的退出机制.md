
视频：context的退出机制 https://meeting.tencent.com/crm/lJLVRoa90b

Q1: s.ctx.Done()作用

**答案：`s.ctx.Done()` 返回一个通道，用于接收 context 被取消或超时的信号，实现优雅退出机制。**

## 基本概念

`context.Done()` 是 Go 语言中用于实现**优雅退出**的核心机制。当 context 被取消、超时或到达截止时间时，`Done()` 返回的通道会被关闭，从而通知所有监听该 context 的 goroutine 停止工作。

## 代码示例

```go
for {
    select {
    case <-s.ctx.Done():
        return  // 收到退出信号，立即返回
    }
}
```

## 工作原理

1. **Done() 返回一个只读通道**：`<-chan struct{}`
2. **通道关闭时机**：
   - 调用 `cancel()` 函数时
   - 到达 `WithTimeout()` 或 `WithDeadline()` 设置的超时时间
   - 父 context 被取消时（子 context 也会被取消）
3. **监听方式**：通过 `select` 语句监听通道关闭事件
4. **通道关闭后的行为**：通道关闭后，`<-s.ctx.Done()` 会立即返回零值，不会阻塞

## 为什么使用 Done()？

### 1. **优雅退出**
```go
// 不使用 context - 无法优雅退出
func badExample() {
    for {
        // 处理任务...
        // 无法从外部停止这个循环！
    }
}

// 使用 context - 可以优雅退出
func goodExample(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return  // 可以随时停止
        default:
            // 处理任务...
        }
    }
}
```

### 2. **避免 goroutine 泄漏**
```go
// 错误示例：goroutine 无法退出
go func() {
    for {
        // 工作...
    }
}()

// 正确示例：可以控制退出
go func() {
    for {
        select {
        case <-ctx.Done():
            return
        default:
            // 工作...
        }
    }
}()
```

### 3. **级联取消**
```go
// 父 context 取消时，所有子 context 也会被取消
parentCtx, cancel := context.WithCancel(context.Background())
defer cancel()

childCtx, _ := context.WithTimeout(parentCtx, time.Second)

// 当 cancel() 被调用时，parentCtx 和 childCtx 都会被取消
```

---

Q2: context 的创建方式

## 1. Background() - 根 context

```go
ctx := context.Background()  // 永不取消的根 context
```

**用途**：作为所有 context 的根节点，通常用于 main 函数或测试中。

## 2. WithCancel() - 可取消的 context

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()  // 确保资源释放

// 在需要取消时调用
cancel()  // 取消 context，Done() 通道会被关闭
```

**用途**：需要手动控制取消时机的场景。

**示例**：
```go
func ExampleWithCancel() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("收到取消信号")
                return
            default:
                fmt.Println("工作中...")
                time.Sleep(100 * time.Millisecond)
            }
        }
    }()
    
    time.Sleep(500 * time.Millisecond)
    cancel()  // 取消 context
    time.Sleep(100 * time.Millisecond)
}
```

## 3. WithTimeout() - 带超时的 context

```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()  // 即使超时也要调用 cancel() 释放资源

// 5秒后自动取消
```

**用途**：需要在指定时间后自动取消的场景。

**示例**：
```go
func ExampleWithTimeout() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("超时退出")
            return
        default:
            fmt.Println("处理中...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}
```

## 4. WithDeadline() - 带截止时间的 context

```go
deadline := time.Now().Add(5 * time.Second)
ctx, cancel := context.WithDeadline(context.Background(), deadline)
defer cancel()

// 到达 deadline 时自动取消
```

**用途**：需要在特定时间点取消的场景。

## 5. WithValue() - 带值的 context

```go
type key string
const userKey key = "user"

ctx := context.WithValue(context.Background(), userKey, "Alice")

// 获取值
user := ctx.Value(userKey).(string)
```

**用途**：在 context 中传递请求级别的数据（如用户ID、请求ID等）。

**注意**：不要用 context 传递可选参数，只传递请求级别的数据。

---

Q3: 在项目中的应用场景

## 实际代码示例

在 `not_complete.go` 中的使用：

```go
for {
    select {
    case <-s.ctx.Done():
        return  // 收到退出信号，立即返回
    case <-checkTicker.C:
        // 查询处理中的区块
        slots, err := s.sc.BlockModel.FindProcessingSlots(...)
        
        for _, slot := range slots {
            select {
            case <-s.ctx.Done():
                return  // 嵌套循环中也要检查退出信号
            case <-sendTicker.C:
                s.errorCh <- uint64(slot.Slot)
            }
        }
    }
}
```

## 关键设计要点

### 1. **在循环中检查 Done()**
```go
for {
    select {
    case <-ctx.Done():
        return  // ✅ 正确：每次循环都检查退出信号
    default:
        // 工作...
    }
}
```

### 2. **在嵌套循环中也要检查**
```go
for {
    select {
    case <-ctx.Done():
        return
    case <-ticker.C:
        for _, item := range items {
            select {
            case <-ctx.Done():  // ✅ 正确：嵌套循环也要检查
                return
            default:
                process(item)
            }
        }
    }
}
```

### 3. **配合 select 使用**
```go
// ✅ 正确：使用 select 监听多个通道
select {
case <-ctx.Done():
    return
case data := <-dataChan:
    process(data)
case <-ticker.C:
    doPeriodicWork()
}

// ❌ 错误：直接阻塞等待，无法响应取消
data := <-dataChan  // 如果 context 被取消，这里无法退出
```

### 4. **在长时间运行的操作中检查**
```go
func processLargeDataset(ctx context.Context, items []Item) error {
    for i, item := range items {
        // ✅ 正确：在长时间操作中定期检查
        if i%100 == 0 {
            select {
            case <-ctx.Done():
                return ctx.Err()  // 返回取消原因
            default:
            }
        }
        process(item)
    }
    return nil
}
```

---

Q4: context.Done() vs 其他退出机制

## 对比分析

### 1. context.Done() vs channel

```go
// 方式1：使用 context（推荐）
ctx, cancel := context.WithCancel(context.Background())
go func() {
    for {
        select {
        case <-ctx.Done():
            return
        }
    }
}()
cancel()  // 取消

// 方式2：使用 channel
done := make(chan struct{})
go func() {
    for {
        select {
        case <-done:
            return
        }
    }
}()
close(done)  // 关闭通道
```

**对比**：
- **context**：✅ 支持超时、截止时间、级联取消、传递值
- **channel**：❌ 功能单一，只支持取消信号

### 2. context.Done() vs sync.WaitGroup

```go
// context：用于取消/超时控制
ctx, cancel := context.WithCancel(context.Background())
go worker(ctx)
cancel()  // 通知 worker 停止

// WaitGroup：用于等待 goroutine 完成
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    worker()
}()
wg.Wait()  // 等待完成
```

**对比**：
- **context**：用于**取消**操作（告诉 goroutine 停止）
- **WaitGroup**：用于**同步**操作（等待 goroutine 完成）

**可以结合使用**：
```go
var wg sync.WaitGroup
ctx, cancel := context.WithCancel(context.Background())

wg.Add(1)
go func() {
    defer wg.Done()
    worker(ctx)  // 使用 context 控制退出
}()

cancel()    // 取消 context
wg.Wait()   // 等待 goroutine 退出
```

### 3. context.Done() vs 全局变量

```go
// ❌ 错误：使用全局变量
var stop bool
go func() {
    for !stop {
        // 工作...
    }
}()
stop = true  // 不可靠，可能有竞态条件

// ✅ 正确：使用 context
ctx, cancel := context.WithCancel(context.Background())
go func() {
    for {
        select {
        case <-ctx.Done():
            return
        default:
            // 工作...
        }
    }
}()
cancel()  // 线程安全
```

---

Q5: 常见错误和最佳实践

## 常见错误

### 1. ❌ 忘记检查 Done()

```go
// 错误：无法响应取消信号
func badExample(ctx context.Context) {
    for {
        process()  // 如果 process() 阻塞，无法退出
    }
}

// 正确：定期检查 Done()
func goodExample(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        default:
            process()
        }
    }
}
```

### 2. ❌ 忘记调用 cancel()

```go
// 错误：可能导致资源泄漏
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
// 忘记 defer cancel()

// 正确：使用 defer 确保释放
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()  // ✅ 即使超时也要调用
```

### 3. ❌ 在嵌套循环中忘记检查

```go
// 错误：内层循环无法响应取消
for {
    select {
    case <-ctx.Done():
        return
    case <-ticker.C:
        for _, item := range items {
            process(item)  // ❌ 如果 items 很多，无法及时退出
        }
    }
}

// 正确：内层循环也要检查
for {
    select {
    case <-ctx.Done():
        return
    case <-ticker.C:
        for _, item := range items {
            select {
            case <-ctx.Done():
                return
            default:
                process(item)
            }
        }
    }
}
```

### 4. ❌ 将 context 存储在结构体中

```go
// ❌ 错误：不要将 context 存储在结构体中
type Service struct {
    ctx context.Context  // 错误！
}

// ✅ 正确：context 应该作为参数传递
type Service struct {
    // 其他字段...
}

func (s *Service) Process(ctx context.Context) {
    // 使用 ctx
}
```

## 最佳实践

### 1. ✅ 总是传递 context 作为第一个参数

```go
// ✅ 正确：context 作为第一个参数
func Process(ctx context.Context, data string) error {
    // ...
}

// ❌ 错误：context 不在第一个位置
func Process(data string, ctx context.Context) error {
    // ...
}
```

### 2. ✅ 使用 defer cancel()

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()  // 确保资源释放
```

### 3. ✅ 检查 ctx.Err() 获取取消原因

```go
select {
case <-ctx.Done():
    return ctx.Err()  // 返回取消原因（context.Canceled 或 context.DeadlineExceeded）
default:
    // 继续工作
}
```

### 4. ✅ 在长时间操作中定期检查

```go
func processLargeDataset(ctx context.Context, items []Item) error {
    for i, item := range items {
        // 每处理 100 个检查一次
        if i%100 == 0 {
            if ctx.Err() != nil {
                return ctx.Err()
            }
        }
        process(item)
    }
    return nil
}
```

### 5. ✅ 不要传递 nil context

```go
// ❌ 错误：传递 nil
func bad(ctx context.Context) {
    if ctx == nil {
        ctx = context.Background()  // 应该使用 context.Background()
    }
}

// ✅ 正确：使用 context.Background() 作为默认值
func good(ctx context.Context) {
    if ctx == nil {
        ctx = context.Background()
    }
}
```

---

Q6: 实际项目中的完整示例

## Service 中的 context 使用模式

```go
type BlockService struct {
    ctx        context.Context
    cancel     func(err error)
    sc         *svc.ServiceContext
    errorCh    chan uint64
}

func NewBlockService(ctx context.Context, ...) *BlockService {
    // 创建可取消的 context
    serviceCtx, cancel := context.WithCancel(ctx)
    
    return &BlockService{
        ctx:     serviceCtx,
        cancel:  cancel,
        // ...
    }
}

func (s *BlockService) Start() {
    // 在 goroutine 中运行
    go s.run()
}

func (s *BlockService) run() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-s.ctx.Done():
            // ✅ 收到退出信号，清理资源并返回
            log.Info("BlockService 收到退出信号")
            return
        case <-ticker.C:
            // 定期执行任务
            s.processBlocks()
        }
    }
}

func (s *BlockService) processBlocks() {
    blocks, err := s.sc.BlockModel.FindProcessingBlocks()
    if err != nil {
        return
    }
    
    for _, block := range blocks {
        // ✅ 在循环中也要检查退出信号
        select {
        case <-s.ctx.Done():
            return
        default:
            s.processBlock(block)
        }
    }
}

func (s *BlockService) Stop() {
    // ✅ 调用 cancel 取消 context，触发 Done() 通道关闭
    s.cancel(ErrServiceStop)
}
```

## 关键要点总结

1. ✅ **Done() 返回只读通道**：当 context 被取消时，通道会关闭
2. ✅ **使用 select 监听**：通过 `select` 语句监听 `Done()` 通道
3. ✅ **在循环中检查**：每次循环都要检查退出信号
4. ✅ **嵌套循环也要检查**：确保所有循环都能响应取消
5. ✅ **使用 defer cancel()**：确保资源释放
6. ✅ **检查 ctx.Err()**：获取取消原因
7. ✅ **context 作为第一个参数**：遵循 Go 语言约定
8. ⚠️ **不要存储 context**：应该作为参数传递
9. ⚠️ **不要传递 nil**：使用 `context.Background()` 作为默认值

---

Q7: 项目中的实际应用 - WithCancelCause

## 项目使用的 context 类型

在实际项目中，使用的是 **`context.WithCancelCause`**（Go 1.20+ 引入），而不是 `WithCancel`。

## 代码示例

### 1. SlotService 中的使用

```go
// slot.go
var ErrServiceStop = errors.New("service stop")

type SlotService struct {
    ctx        context.Context
    cancel     func(err error)  // 注意：签名是 func(err error)
    // ... 其他字段
}

func NewSlotService(sc *svc.ServiceContext, slotChan, errChan chan uint64) *SlotService {
    // ✅ 使用 WithCancelCause 创建 context
    ctx, cancel := context.WithCancelCause(context.Background())
    return &SlotService{
        ctx:    ctx,
        cancel: cancel,  // CancelCauseFunc 类型
        // ...
    }
}

func (s *SlotService) Stop() {
    s.Info("stop slot")
    // ✅ 取消时传入错误原因
    s.cancel(ErrServiceStop)
    // ... 清理资源
}
```

### 2. BlockService 中的使用

```go
// block.go
var ErrServiceStop = errors.New("service stop")

type BlockService struct {
    ctx        context.Context
    cancel     func(err error)
    // ... 其他字段
}

func NewBlockService(...) *BlockService {
    // ✅ 使用 WithCancelCause
    ctx, cancel := context.WithCancelCause(context.Background())
    return &BlockService{
        ctx:    ctx,
        cancel: cancel,
        // ...
    }
}

func (s *BlockService) Stop() {
    // ✅ 取消时传入错误原因
    s.cancel(ErrServiceStop)
    // ... 清理资源
}
```

## WithCancelCause vs WithCancel

### 对比表格

| 特性 | `WithCancel` | `WithCancelCause` |
|------|-------------|-------------------|
| **Go 版本要求** | Go 1.7+ | Go 1.20+ |
| **返回类型** | `CancelFunc` | `CancelCauseFunc` |
| **取消函数签名** | `func()` | `func(error)` |
| **取消原因** | 只能通过 `ctx.Err()` 获取 `context.Canceled` | 可以通过 `context.Cause(ctx)` 获取具体原因 |
| **使用场景** | 简单取消场景 | 需要记录取消原因的场景 |

### 代码对比

```go
// 方式1：使用 WithCancel（旧方式）
ctx, cancel := context.WithCancel(context.Background())
cancel()  // 取消，无法记录原因
err := ctx.Err()  // 只能得到 context.Canceled

// 方式2：使用 WithCancelCause（项目使用的方式）
ctx, cancel := context.WithCancelCause(context.Background())
cancel(ErrServiceStop)  // 取消并记录原因
err := ctx.Err()  // 得到 context.Canceled
cause := context.Cause(ctx)  // 得到 ErrServiceStop（具体原因）
```

## 为什么使用 WithCancelCause？

### 1. **可追溯的取消原因**

```go
// 定义不同的取消原因
var (
    ErrServiceStop = errors.New("service stop")
    ErrTimeout     = errors.New("timeout")
    ErrShutdown    = errors.New("shutdown")
    ErrError       = errors.New("error occurred")
)

// 根据不同的场景取消
func (s *SlotService) Stop() {
    s.cancel(ErrServiceStop)  // 明确记录停止原因
}

// 获取取消原因
if ctx.Err() != nil {
    cause := context.Cause(ctx)
    switch cause {
    case ErrServiceStop:
        log.Info("服务正常停止")
    case ErrTimeout:
        log.Warn("服务超时停止")
    case ErrShutdown:
        log.Info("系统关闭")
    }
}
```

### 2. **更好的错误处理和日志记录**

```go
func (s *SlotService) run() {
    for {
        select {
        case <-s.ctx.Done():
            // ✅ 可以获取具体的取消原因
            cause := context.Cause(s.ctx)
            s.Infof("服务停止，原因: %v", cause)
            return
        default:
            // 工作...
        }
    }
}
```

### 3. **便于调试和监控**

```go
// 在服务停止时记录原因
func (s *SlotService) Stop() {
    s.cancel(ErrServiceStop)
    
    // 可以记录到监控系统
    metrics.RecordServiceStop(context.Cause(s.ctx))
    
    // 可以记录到日志
    s.Infof("服务停止，原因: %v", context.Cause(s.ctx))
}
```

## 实际应用场景

### 场景1：服务管理

```go
type Service struct {
    ctx    context.Context
    cancel func(err error)
}

func NewService() *Service {
    ctx, cancel := context.WithCancelCause(context.Background())
    return &Service{ctx: ctx, cancel: cancel}
}

func (s *Service) Stop(reason error) {
    s.cancel(reason)  // 传入停止原因
}

func (s *Service) Start() {
    go func() {
        for {
            select {
            case <-s.ctx.Done():
                cause := context.Cause(s.ctx)
                log.Info("服务停止，原因:", cause)
                return
            default:
                // 工作...
            }
        }
    }()
}
```

### 场景2：错误传播

```go
// 父服务取消时，子服务可以知道原因
parentCtx, parentCancel := context.WithCancelCause(context.Background())
childCtx, _ := context.WithCancelCause(parentCtx)

// 父服务取消
parentCancel(ErrShutdown)

// 子服务可以获取父服务的取消原因
cause := context.Cause(childCtx)  // 返回 ErrShutdown
```

### 场景3：多级服务管理

```go
// 服务组管理多个服务
type ServiceGroup struct {
    services []*Service
    ctx      context.Context
    cancel   func(err error)
}

func (sg *ServiceGroup) StopAll(reason error) {
    // 取消所有服务，并记录原因
    sg.cancel(reason)
    
    // 每个服务都可以获取停止原因
    for _, s := range sg.services {
        if s.ctx.Err() != nil {
            cause := context.Cause(s.ctx)
            log.Info("服务停止，原因:", cause)
        }
    }
}
```

## 关键要点

1. ✅ **使用 `WithCancelCause`**：项目中使用的是 `WithCancelCause`，不是 `WithCancel`
2. ✅ **取消函数签名**：`CancelCauseFunc` 需要传入 `error` 参数
3. ✅ **获取取消原因**：使用 `context.Cause(ctx)` 获取具体的取消原因
4. ✅ **错误定义**：定义明确的错误类型（如 `ErrServiceStop`）
5. ✅ **日志记录**：在服务停止时记录取消原因，便于调试
6. ⚠️ **Go 版本要求**：需要 Go 1.20+ 才能使用 `WithCancelCause`

## 项目中的最佳实践

```go
// 1. 定义明确的错误类型
var ErrServiceStop = errors.New("service stop")

// 2. 创建 context
ctx, cancel := context.WithCancelCause(context.Background())

// 3. 停止时传入原因
func (s *Service) Stop() {
    s.cancel(ErrServiceStop)
}

// 4. 在循环中检查并记录原因
for {
    select {
    case <-s.ctx.Done():
        cause := context.Cause(s.ctx)
        s.Infof("服务停止，原因: %v", cause)
        return
    default:
        // 工作...
    }
}
```