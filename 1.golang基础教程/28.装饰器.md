录制：golang基础24_装饰器.mp4
日期：2026-01-31 00:07:23
录制文件：https://meeting.tencent.com/crm/293zMY3qf7

Q1: 什么是装饰器？

## 面试回答（精简版）

**定义**：装饰器（Decorator）是一种设计模式，通过包装函数来增强其功能，而不修改原函数本身。

**核心特点**：
- **不修改原函数**：原函数保持不变
- **动态增强**：在运行时添加新功能
- **可组合**：多个装饰器可以链式组合
- **透明性**：对调用者来说，装饰后的函数和原函数接口相同

**Go中的实现**：
- 使用**高阶函数**（Higher-Order Function）
- 函数作为参数和返回值
- 类似于中间件（Middleware）模式

**示例**：
```go
// 原函数
func greet(name string) {
    fmt.Printf("Hello, %s!\n", name)
}

// 装饰器：添加日志
func logDecorator(fn func(string)) func(string) {
    return func(name string) {
        fmt.Println("Before calling function")
        fn(name)
        fmt.Println("After calling function")
    }
}

// 使用装饰器
decoratedGreet := logDecorator(greet)
decoratedGreet("Alice")
// 输出：
// Before calling function
// Hello, Alice!
// After calling function
```

---

## 详细说明

### 1. 装饰器的定义

**装饰器模式（Decorator Pattern）**是一种结构型设计模式，允许在不修改原函数的情况下，动态地给函数添加新功能。

**关键概念**：
- **包装（Wrapper）**：装饰器包装原函数
- **增强（Enhancement）**：添加新功能（日志、计时、重试等）
- **组合（Composition）**：多个装饰器可以组合使用

### 2. Go中的装饰器实现

Go语言中，装饰器通过**高阶函数**（Higher-Order Function）实现：

```go
// 装饰器函数签名
type Decorator func(func()) func()

// 通用装饰器模板
func Decorator(originalFunc func(...)) func(...) {
    return func(...) {
        // 前置处理
        // ...
        
        // 调用原函数
        originalFunc(...)
        
        // 后置处理
        // ...
    }
}
```

### 3. 装饰器 vs 其他模式

| 特性 | 装饰器 | 继承 | 组合 |
|------|--------|------|------|
| **修改原函数** | ❌ 不修改 | ✅ 修改 | ❌ 不修改 |
| **运行时增强** | ✅ 支持 | ❌ 编译时 | ✅ 支持 |
| **灵活性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **Go支持** | ✅ 原生支持 | ❌ 不支持 | ✅ 支持 |

### 4. 装饰器的典型应用

**常见场景**：
- **日志记录**：记录函数调用和结果
- **性能监控**：统计执行时间
- **错误处理**：统一错误处理逻辑
- **重试机制**：自动重试失败的操作（详见 `experiments/test_decorator_retry.go`）
- **权限验证**：检查权限后再执行
- **缓存**：添加缓存层

---

Q2: 装饰器的主要作用？

## 面试回答（精简版）

**主要作用**：

1. **功能增强**：在不修改原函数的情况下，添加新功能（日志、计时、重试等）
2. **横切关注点**：处理日志、监控、错误处理等横切关注点
3. **代码复用**：将通用逻辑抽取到装饰器中，避免重复代码
4. **关注点分离**：业务逻辑和横切关注点分离，代码更清晰
5. **灵活组合**：多个装饰器可以链式组合，灵活配置

**典型应用**：
- **HTTP中间件**：认证、日志、限流等
- **函数增强**：日志、计时、重试、缓存
- **错误处理**：统一错误处理和恢复

**示例**：
```go
// 日志装饰器
func logDecorator(fn func()) func() {
    return func() {
        log.Println("Before execution")
        fn()
        log.Println("After execution")
    }
}

// 计时装饰器
func timingDecorator(fn func()) func() {
    return func() {
        start := time.Now()
        fn()
        log.Printf("Execution time: %v", time.Since(start))
    }
}

// 组合使用
decoratedFn := logDecorator(timingDecorator(originalFn))
```

---

## 详细说明

### 1. 功能增强

**作用**：在不修改原函数的情况下，添加新功能。

**示例：日志装饰器**

```go
// 原函数
func processOrder(orderID string) error {
    // 处理订单逻辑
    return nil
}

// 日志装饰器
func logDecorator(fn func(string) error) func(string) error {
    return func(orderID string) error {
        log.Printf("开始处理订单: %s", orderID)
        err := fn(orderID)
        if err != nil {
            log.Printf("处理订单失败: %s, error: %v", orderID, err)
        } else {
            log.Printf("处理订单成功: %s", orderID)
        }
        return err
    }
}

// 使用
decoratedProcess := logDecorator(processOrder)
decoratedProcess("order-123")
```

**优势**：
- ✅ 原函数保持不变
- ✅ 日志逻辑集中管理
- ✅ 可以随时添加或移除日志

### 2. 横切关注点处理

**作用**：处理日志、监控、错误处理等横切关注点。

**横切关注点（Cross-Cutting Concerns）**：
- 日志记录
- 性能监控
- 错误处理
- 权限验证
- 事务管理

**示例：HTTP中间件（装饰器模式）**

```go
// HTTP处理器类型
type HandlerFunc func(http.ResponseWriter, *http.Request)

// 认证装饰器
func authMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 验证token
        token := r.Header.Get("Authorization")
        if !isValidToken(token) {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // 调用下一个处理器
        next(w, r)
    }
}

// 日志装饰器
func logMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Printf("Request: %s %s", r.Method, r.URL.Path)
        next(w, r)
        log.Printf("Response: %s %s", r.Method, r.URL.Path)
    }
}

// 组合使用
handler := logMiddleware(authMiddleware(handleOrder))
```

### 3. 代码复用

**作用**：将通用逻辑抽取到装饰器中，避免重复代码。

**问题场景**：多个函数都需要相同的逻辑

```go
// ❌ 不好的做法：重复代码
func processOrder1(orderID string) error {
    log.Println("开始处理")  // 重复
    start := time.Now()      // 重复
    
    // 业务逻辑1
    // ...
    
    log.Printf("耗时: %v", time.Since(start))  // 重复
    return nil
}

func processOrder2(orderID string) error {
    log.Println("开始处理")  // 重复
    start := time.Now()      // 重复
    
    // 业务逻辑2
    // ...
    
    log.Printf("耗时: %v", time.Since(start))  // 重复
    return nil
}
```

**解决方案：使用装饰器**

```go
// ✅ 好的做法：使用装饰器
func logAndTimeDecorator(fn func(string) error) func(string) error {
    return func(orderID string) error {
        log.Println("开始处理")
        start := time.Now()
        
        err := fn(orderID)
        
        log.Printf("耗时: %v", time.Since(start))
        return err
    }
}

// 使用
processOrder1 := logAndTimeDecorator(func(orderID string) error {
    // 业务逻辑1
    return nil
})

processOrder2 := logAndTimeDecorator(func(orderID string) error {
    // 业务逻辑2
    return nil
})
```

### 4. 关注点分离

**作用**：业务逻辑和横切关注点分离，代码更清晰。

**示例**：

```go
// 业务逻辑（纯函数）
func calculateTotal(items []Item) float64 {
    total := 0.0
    for _, item := range items {
        total += item.Price * float64(item.Quantity)
    }
    return total
}

// 装饰器：添加缓存
func cacheDecorator(fn func([]Item) float64) func([]Item) float64 {
    cache := make(map[string]float64)
    return func(items []Item) float64 {
        key := generateKey(items)
        if val, ok := cache[key]; ok {
            return val
        }
        val := fn(items)
        cache[key] = val
        return val
    }
}

// 装饰器：添加日志
func logDecorator(fn func([]Item) float64) func([]Item) float64 {
    return func(items []Item) float64 {
        log.Printf("计算总价，商品数量: %d", len(items))
        result := fn(items)
        log.Printf("总价: %.2f", result)
        return result
    }
}

// 组合使用
decoratedCalculate := logDecorator(cacheDecorator(calculateTotal))
```

**优势**：
- ✅ 业务逻辑清晰
- ✅ 横切关注点独立
- ✅ 易于测试和维护

### 5. 灵活组合

**作用**：多个装饰器可以链式组合，灵活配置。

**示例：链式组合**

```go
// 多个装饰器
func logDecorator(fn func()) func() {
    return func() {
        log.Println("Before")
        fn()
        log.Println("After")
    }
}

func timingDecorator(fn func()) func() {
    return func() {
        start := time.Now()
        fn()
        log.Printf("Time: %v", time.Since(start))
    }
}

func retryDecorator(maxRetries int, fn func() error) func() error {
    return func() error {
        var err error
        for i := 0; i < maxRetries; i++ {
            err = fn()
            if err == nil {
                return nil
            }
            time.Sleep(time.Second)
        }
        return err
    }
}

// 组合使用
originalFn := func() error {
    // 业务逻辑
    return nil
}

// 链式组合：日志 -> 计时 -> 重试
decoratedFn := logDecorator(
    func() {
        timingDecorator(
            func() {
                retryDecorator(3, originalFn)()
            },
        )()
    },
)
```

### 6. 实际应用场景

#### 场景1：HTTP中间件（最常见）

```go
// 项目中的实际应用（参考 apps/gateway/middleware/auth.go）
func AuthMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 验证token
        token := r.Header.Get("Authorization")
        if !isValidToken(token) {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // 调用下一个处理器
        next(w, r)
    }
}

// 使用
http.HandleFunc("/api/order", AuthMiddleware(handleOrder))
```

#### 场景2：函数重试

```go
// 重试装饰器
func retryDecorator(maxRetries int, delay time.Duration, fn func() error) func() error {
    return func() error {
        var lastErr error
        for i := 0; i < maxRetries; i++ {
            err := fn()
            if err == nil {
                return nil
            }
            lastErr = err
            time.Sleep(delay)
        }
        return fmt.Errorf("failed after %d retries: %w", maxRetries, lastErr)
    }
}

// 使用
decoratedCall := retryDecorator(3, time.Second, func() error {
    return callAPI()
})
```

#### 场景3：性能监控

```go
// 性能监控装饰器
func performanceDecorator(fn func()) func() {
    return func() {
        start := time.Now()
        fn()
        duration := time.Since(start)
        
        // 记录性能指标
        metrics.RecordDuration("function_execution", duration)
        
        if duration > time.Second {
            log.Printf("Slow execution: %v", duration)
        }
    }
}
```

#### 场景4：缓存装饰器

```go
// 缓存装饰器
func cacheDecorator(ttl time.Duration, fn func(string) (string, error)) func(string) (string, error) {
    cache := make(map[string]cacheEntry)
    mu := sync.RWMutex{}
    
    return func(key string) (string, error) {
        mu.RLock()
        if entry, ok := cache[key]; ok && time.Since(entry.time) < ttl {
            mu.RUnlock()
            return entry.value, nil
        }
        mu.RUnlock()
        
        // 调用原函数
        value, err := fn(key)
        if err != nil {
            return "", err
        }
        
        // 更新缓存
        mu.Lock()
        cache[key] = cacheEntry{value: value, time: time.Now()}
        mu.Unlock()
        
        return value, nil
    }
}

type cacheEntry struct {
    value string
    time  time.Time
}
```

### 7. 装饰器的优势

**优势**：

1. **不修改原函数**：
   - 原函数保持不变
   - 降低引入bug的风险

2. **动态增强**：
   - 运行时添加功能
   - 灵活配置

3. **可组合性**：
   - 多个装饰器可以组合
   - 按需添加功能

4. **关注点分离**：
   - 业务逻辑和横切关注点分离
   - 代码更清晰

5. **易于测试**：
   - 原函数易于测试
   - 装饰器可以单独测试

### 8. 装饰器的注意事项

**注意事项**：

1. **性能开销**：
   - 装饰器会增加函数调用层次
   - 注意性能影响

2. **调试困难**：
   - 多层装饰器可能难以调试
   - 需要清晰的日志

3. **类型安全**：
   - Go的类型系统可能限制装饰器的通用性
   - 需要使用接口或泛型（Go 1.18+）

4. **过度使用**：
   - 不要过度使用装饰器
   - 保持代码简洁

### 9. Go 1.18+ 泛型装饰器

**使用泛型实现通用装饰器**：

```go
// 通用装饰器（Go 1.18+）
func logDecorator[T any](fn func(T) error) func(T) error {
    return func(arg T) error {
        log.Printf("Calling function with arg: %v", arg)
        err := fn(arg)
        if err != nil {
            log.Printf("Function returned error: %v", err)
        }
        return err
    }
}

// 使用
decoratedFn := logDecorator(func(s string) error {
    // 业务逻辑
    return nil
})
```

### 10. 总结

**装饰器的主要作用**：

1. ✅ **功能增强**：添加日志、计时、重试等功能
2. ✅ **横切关注点**：处理日志、监控、错误处理
3. ✅ **代码复用**：避免重复代码
4. ✅ **关注点分离**：业务逻辑和横切关注点分离
5. ✅ **灵活组合**：多个装饰器可以链式组合

**适用场景**：
- HTTP中间件（认证、日志、限流）
- 函数增强（日志、计时、重试、缓存）
- 错误处理和恢复
- 性能监控和统计

**Go中的实现**：
- 使用高阶函数
- 函数作为参数和返回值
- 类似于中间件模式

---

## 实践示例

### 运行示例代码

```bash
cd /home/ubuntu/dex_full/web3fun-Dex/1.基础篇/1.golang基础教程/experiments
go run decorator_demo.go
```

**示例代码包含**：
1. **基本装饰器** - 日志装饰器
2. **带返回值的装饰器** - 日志装饰器（带返回值）
3. **计时装饰器** - 性能监控
4. **重试装饰器** - 自动重试失败的操作
5. **错误处理装饰器** - 统一错误处理
6. **缓存装饰器** - 添加缓存层
7. **链式组合** - 多个装饰器组合
8. **HTTP中间件模式** - 认证和日志中间件

### 项目中的实际应用

**参考代码**：
- `apps/gateway/middleware/auth.go` - 认证中间件（装饰器模式）
- `apps/gateway/middleware/response.go` - 响应处理中间件
- `apps/gateway/middleware/log.go` - 日志中间件

**示例**：
```go
// 项目中的实际应用
func AuthMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 验证token
        // ...
        next(w, r)  // 调用下一个处理器
    }
}
```

