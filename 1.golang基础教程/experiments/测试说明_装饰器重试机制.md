# 装饰器在重试机制中的应用演示

## 目的

演示如何使用装饰器模式实现重试机制，展示装饰器的应用场景和优势。

## 快速开始

```bash
cd /home/ubuntu/dex_full/web3fun-Dex/1.基础篇/1.golang基础教程/experiments
go run test_decorator_retry.go
```

## 演示内容

程序会展示两个场景的对比：

### 场景1：不使用装饰器

**代码**：
```go
err := api.Call()
if err != nil {
    // 需要手动处理错误，无法自动重试
}
```

**问题**：
- ❌ 失败后无法自动重试
- ❌ 需要手动编写重试逻辑
- ❌ 代码重复，不易维护

### 场景2：使用装饰器

**代码**：
```go
config := RetryConfig{MaxRetries: 3, Delay: 200ms}
decoratedCall := RetryDecorator(config, api.Call)
err := decoratedCall()  // 自动重试
```

**优势**：
- ✅ 自动重试逻辑，代码更简洁
- ✅ 不修改原函数代码（`api.Call` 保持不变）
- ✅ 重试逻辑可复用，可以应用到其他函数
- ✅ 易于维护，重试策略集中管理

## 核心实现

### 重试装饰器

```go
func RetryDecorator(config RetryConfig, fn func() error) func() error {
    return func() error {
        for attempt := 0; attempt <= config.MaxRetries; attempt++ {
            err := fn()
            if err == nil {
                return nil // 成功
            }
            if attempt < config.MaxRetries {
                time.Sleep(config.Delay) // 等待后重试
            }
        }
        return fmt.Errorf("重试失败")
    }
}
```

### 使用示例

```go
// 1. 定义原函数
apiCall := func() error {
    return callAPI()
}

// 2. 配置重试策略
config := RetryConfig{
    MaxRetries: 3,
    Delay:      200 * time.Millisecond,
}

// 3. 应用装饰器
decoratedCall := RetryDecorator(config, apiCall)

// 4. 调用（自动重试）
err := decoratedCall()
```

## 装饰器的优势

1. **不修改原函数**：原函数保持不变，符合开闭原则
2. **代码复用**：重试逻辑可以应用到多个函数
3. **灵活配置**：可以配置重试次数和延迟时间
4. **易于维护**：重试逻辑集中管理，修改方便

## 实际应用场景

- HTTP API调用重试
- 数据库连接重试
- 文件操作重试
- 任何可能失败的操作
