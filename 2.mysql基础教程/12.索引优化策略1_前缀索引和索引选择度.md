目标
1.理解前缀索引优化方案
2.理解索引最佳选择

视频：
录制：mysql基础6_索引优化策略1_前缀索引和索引选择度.mp4
日期：2026-01-26 19:39:26
录制文件：https://meeting.tencent.com/crm/NQRVbODp5e


内容：
Q1: 前缀索引优化好处?
You can often save space and get good performance by indexing the first few charac‐
ters instead of the whole 


Q2： less selective?
more ambiguous (更大的模糊性)


Q3: Index Selectivity 定义
Index selectivity is the ratio of the number of distinct indexed values (the cardinality) to the total number of rows in the table (#T), and it
ranges from 1/#T to 1.

示例（Example）：

假设有一个用户表 users，包含 1000 行数据：

CREATE TABLE users (
  id INT PRIMARY KEY,
  email VARCHAR(100),
  gender ENUM('M', 'F'),
  country VARCHAR(50)
);

INSERT INTO users VALUES
(1, 'user1@example.com', 'M', 'USA'),
(2, 'user2@example.com', 'F', 'USA'),
...
(1000, 'user1000@example.com', 'M', 'China');

情况1：高选择性索引（High Selectivity）
- 索引列：email（假设每个 email 都不同）
- 不同值的数量（cardinality）= 1000
- 总行数（#T）= 1000
- Selectivity = 1000 / 1000 = 1.0（最高，最佳）
- 说明：每个值都是唯一的，索引非常有效

情况2：低选择性索引（Low Selectivity）
- 索引列：gender（只有 'M' 和 'F' 两个值）
- 不同值的数量（cardinality）= 2
- 总行数（#T）= 1000
- Selectivity = 2 / 1000 = 0.002（很低）
- 说明：只有 2 个不同值，索引效果很差，几乎等同于全表扫描

情况3：中等选择性索引（Medium Selectivity）
- 索引列：country（假设有 50 个不同的国家）
- 不同值的数量（cardinality）= 50
- 总行数（#T）= 1000
- Selectivity = 50 / 1000 = 0.05（中等）
- 说明：比 gender 好，但不如 email

计算选择度的 SQL 示例：
-- 查看某个列的选择度
SELECT 
  COUNT(DISTINCT email) / COUNT(*) AS email_selectivity,
  COUNT(DISTINCT gender) / COUNT(*) AS gender_selectivity,
  COUNT(DISTINCT country) / COUNT(*) AS country_selectivity
FROM users;

规则：
- Selectivity 越高越好（接近 1.0 最好）
- Selectivity 越低，索引效果越差
- 通常 Selectivity < 0.1 的列不适合单独建索引
- 对于低选择度的列，可以考虑使用复合索引或前缀索引 