数据：
1. 创建表
CREATE TABLE `people` (
  `last_name` varchar(50) NOT NULL,
  `first_name` varchar(50) NOT NULL,
  `dob` date NOT NULL,
  KEY `last_name` (`last_name`,`first_name`,`dob`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;


2. 创建测试数据
INSERT INTO `people` (`last_name`, `first_name`, `dob`) VALUES
('Allen', 'Cuba', '1960-01-01'),
('Allen', 'K', '1970-05-15'),
('Allen', 'Kevin', '1980-03-20'),
('Allen', 'Kate', '1990-07-10'),
('Anderson', 'John', '1965-02-14'),
('Anderson', 'Jane', '1975-08-22'),
('Baker', 'Robert', '1985-11-30'),
('Barrymore', 'Drew', '1975-02-22'),
('Barrymore', 'John', '1960-12-01'),
('Johnson', 'Michael', '1972-04-18'),
('Johnson', 'Sarah', '1988-09-05'),
('Jackson', 'David', '1992-01-25'),
('Jackson', 'Lisa', '1985-06-12'),
('Jones', 'William', '1978-10-08'),
('Jones', 'Emily', '1995-03-15'),
('Smith', 'James', '1968-07-04'),
('Smith', 'Mary', '1982-12-20'),
('Williams', 'Richard', '1970-09-11'),
('Williams', 'Patricia', '1987-05-03'),
('Brown', 'Charles', '1990-08-17');


3. 查看不同的查询方式的区别（是否命中索引）

使用 EXPLAIN 命令查看查询执行计划，判断是否命中索引。

关键字段说明：
- `key`: 使用的索引名称（注意：这是索引的名字，不是列名！）
  - 如果为 NULL 则表示未使用索引
  - 例如：`key = 'last_name'` 表示使用了名为 `last_name` 的索引（这是一个复合索引 `(last_name, first_name, dob)`）
- `key_len`: 使用的索引长度（字节数），可以判断使用了索引的哪些列
  - 复合索引中，`key_len` 的大小可以告诉你使用了索引的前几个列
  - 例如：如果 `key_len` 较小，可能只用了 `last_name`；如果较大，可能用了 `last_name` 和 `first_name`
- `type`: 访问类型
  - `ref` 或 `range`: 使用索引进行高效查找
  - `index`: 全索引扫描（比全表扫描好，但不如 ref/range）
  - `ALL`: 全表扫描（最差）
- `rows`: 扫描的行数，越少越好
- `Extra`: 额外信息
  - `Using index`: 覆盖索引（Covering Index），所有需要的数据都在索引中，无需回表
  - `Using where`: 使用 WHERE 条件过滤

案例1：命中索引的查询

-- 1.1 完整匹配（使用所有索引字段）
EXPLAIN SELECT * FROM people WHERE last_name = 'Allen' AND first_name = 'Cuba' AND dob = '1960-01-01';
-- 预期：key = 'last_name', type = 'ref'

-- 1.2 最左前缀匹配（只使用第一个索引字段）
EXPLAIN SELECT * FROM people WHERE last_name = 'Allen';
-- 预期：key = 'last_name', type = 'ref'

-- 1.3 列前缀匹配
EXPLAIN SELECT * FROM people WHERE last_name LIKE 'J%';
-- 预期：key = 'last_name', type = 'range'

-- 1.4 范围查询
EXPLAIN SELECT * FROM people WHERE last_name BETWEEN 'Allen' AND 'Barrymore';
-- 预期：key = 'last_name', type = 'range'

-- 1.5 精确匹配 + 范围匹配
EXPLAIN SELECT * FROM people WHERE last_name = 'Allen' AND first_name LIKE 'K%';
-- 预期：key = 'last_name', type = 'range'

案例2：不命中索引的查询

-- 2.1 没有遵循最左匹配原则（没有使用第一个索引字段）
EXPLAIN SELECT * FROM people WHERE first_name = 'Cuba';
-- 实际结果：key = 'last_name', type = 'index', Extra = 'Using where; Using index'
-- 说明：
-- 1. possible_keys = NULL：没有索引可以用于高效过滤（因为违反了最左匹配原则）
-- 2. 但 MySQL 仍然选择了扫描整个索引（type = 'index'）而不是全表扫描（type = 'ALL'）
-- 3. 原因：这是一个"覆盖索引"（Covering Index）的情况
--    - SELECT * 需要的所有列（last_name, first_name, dob）都在索引中
--    - 索引通常比表数据更小、更紧凑
--    - MySQL 扫描整个索引，然后应用 WHERE first_name = 'Cuba' 过滤
--    - 这样比全表扫描更高效，但仍不如使用索引进行直接查找（type = 'ref'）
-- 4. 如果表中有其他列不在索引中，或者索引不是覆盖索引，则可能退化为全表扫描

-- 2.2 跳过中间的索引字段
EXPLAIN SELECT * FROM people WHERE last_name = 'Allen' AND dob = '1960-01-01';
-- 预期：key = 'last_name', type = 'ref' (只使用了部分索引，dob字段无法使用)

-- 2.3 范围查询后的字段无法使用索引
EXPLAIN SELECT * FROM people WHERE last_name = 'Allen' AND first_name LIKE 'K%' AND dob = '1960-01-01';
-- 实际结果：key = 'last_name', type = 'range'
-- 说明：
-- 1. `key = 'last_name'`：这是索引的名称，不是列名！
--    - 索引定义：KEY `last_name` (`last_name`,`first_name`,`dob`)
--    - 索引名称是 `last_name`，但它包含三个列：`last_name`, `first_name`, `dob`
-- 2. `type = 'range'`：表示使用了范围查询
-- 3. 查看 `key_len` 可以判断实际使用了索引的哪些列：
--    - 如果 `key_len` 只包含 `last_name` 的长度：只使用了第一个列
--    - 如果 `key_len` 包含 `last_name` + `first_name` 的长度：使用了前两个列
--    - 在这个查询中，`first_name LIKE 'K%'` 是范围查询，所以：
--      * `last_name = 'Allen'` ✓ 可以使用索引（精确匹配）
--      * `first_name LIKE 'K%'` ✓ 可以使用索引（范围查询，但会停止索引使用）
--      * `dob = '1960-01-01'` ✗ 无法使用索引（因为前面的 `first_name` 使用了范围查询）
-- 4. 规则：一旦索引中某个列使用了范围查询（>, <, LIKE, BETWEEN等），后面的列就无法用于索引查找

